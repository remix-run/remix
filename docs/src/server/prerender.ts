import * as cp from 'node:child_process'
import { existsSync } from 'node:fs'
import * as fs from 'node:fs/promises'
import * as path from 'node:path'
import * as util from 'node:util'
import { parse } from 'node-html-parser'
import * as semver from 'semver'
import { type Router } from 'remix/fetch-router'
import { createRouter } from './router.tsx'
import type { AppContext } from './components.tsx'

let { values: cliArgs } = util.parseArgs({
  options: {
    dir: {
      type: 'string',
      short: 'd',
      default: 'build/site',
    },
    local: {
      type: 'boolean',
      short: 'l',
    },
  },
})

const outputDir = path.join(process.cwd(), cliArgs.dir)
const docsRouter = cliArgs.local
  ? createRouter()
  : createRouter(await getVersionsToBuild(outputDir))

await spider(docsRouter, outputDir)

// Spider the website served by router, beginning at /
async function spider(router: Router, outputDir: string, urlQueue = ['/']) {
  await fs.mkdir(outputDir, { recursive: true })

  // Track URLs we have already downloaded to avoid loops
  let downloadedUrls = new Set<string>()

  while (urlQueue.length > 0) {
    await crawl(router, urlQueue, downloadedUrls, outputDir)
  }

  console.log(`\nCrawling complete!`)
}

async function crawl(
  router: Router,
  urlQueue: string[],
  downloadedUrls: Set<string>,
  outputDir: string,
): Promise<void> {
  let urlPath = urlQueue.shift()
  if (!urlPath || downloadedUrls.has(urlPath)) {
    return
  }

  let response
  try {
    response = await router.fetch(new Request(`http://localhost${urlPath}`))
    if (!response.ok) {
      throw new Error(`Error fetching ${urlPath}: ${response.status} ${response.statusText}`)
    }
  } catch (error) {
    console.error('Error fetching', urlPath)
    throw error
  }

  let isHtmlFile = response.headers.get('Content-Type')?.includes('text/html')

  // Always put `index.html` files into directories - this leads to the best
  // support with and without trailing slashes on github pages:
  // https://github.com/slorber/trailing-slash-guide?tab=readme-ov-file#summary
  let outputPath = isHtmlFile
    ? path.join(outputDir, urlPath, 'index.html')
    : path.join(outputDir, urlPath)

  console.log(
    `${isHtmlFile ? `Crawled` : `  Asset`} ` +
      `${urlPath} -> ./${path.relative(process.cwd(), outputPath)}`,
  )

  await fs.mkdir(path.dirname(outputPath), { recursive: true })

  if (isHtmlFile) {
    let html = await response.text()
    await fs.writeFile(outputPath, html, 'utf-8')

    // Parse HTML files for other resources/links to add to queue
    urlQueue.push(
      ...parse(html)
        .querySelectorAll('a:not([rel="nofollow"]),link')
        .map((link) => link.getAttribute('href'))
        .filter((href) => href && !isAbsoluteUrl(href) && !downloadedUrls.has(href))
        .map((href) => resolveRelativeLink(href!, urlPath)),
    )
  } else {
    let content = await response.arrayBuffer()
    await fs.writeFile(outputPath, new Uint8Array(content))
  }

  downloadedUrls.add(urlPath)
}

function isAbsoluteUrl(href: string): boolean {
  return href.startsWith('http://') || href.startsWith('https://') || href.startsWith('//')
}

function resolveRelativeLink(link: string, url: string): string {
  if (link.startsWith('/')) {
    return link
  }

  // Handle relative paths like '../' or 'page'
  let base = url.endsWith('/') ? url : path.dirname(url)
  return path.posix.join(base, link)
}

async function getVersionsToBuild(outputDir: string): Promise<AppContext['versions']> {
  let versions = existsSync(outputDir)
    ? (await fs.readdir(outputDir, { withFileTypes: true }))
        .filter((entry) => entry.isDirectory() && entry.name.startsWith('v'))
        .map((entry) => entry.name)
    : []

  const alreadyBuilt = new Set(versions)

  return cp
    .execSync('git tag', { encoding: 'utf-8' })
    .trim()
    .split('\n')
    .filter((tag) => tag.startsWith('remix@3'))
    .map((tag) => tag.replace('remix@', 'v'))
    .filter((tag) => semver.valid(tag) && !semver.prerelease(tag) && !alreadyBuilt.has(tag))
    .map((v) => ({ name: v, version: v }))
}
