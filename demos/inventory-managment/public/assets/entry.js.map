{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@remix-run+dom@0.0.0-experimental-remix-jam.6/node_modules/@remix-run/dom/dist/lib/invariant.js", "../../../../node_modules/.pnpm/@remix-run+dom@0.0.0-experimental-remix-jam.6/node_modules/@remix-run/dom/dist/lib/diff-dom.js", "../../../../node_modules/.pnpm/@remix-run+events@0.0.0-experimental-remix-jam.5/node_modules/@remix-run/events/dist/lib/events.js", "../../../../node_modules/.pnpm/@remix-run+events@0.0.0-experimental-remix-jam.5/node_modules/@remix-run/events/dist/lib/targets.js", "../../../../node_modules/.pnpm/@remix-run+events@0.0.0-experimental-remix-jam.5/node_modules/@remix-run/events/dist/lib/event-type.js", "../../../../node_modules/.pnpm/@remix-run+style@0.0.0-experimental-remix-jam.5/node_modules/@remix-run/style/dist/lib/style.js", "../../../../node_modules/.pnpm/@remix-run+style@0.0.0-experimental-remix-jam.5/node_modules/@remix-run/style/dist/lib/stylesheet.js", "../../../../node_modules/.pnpm/@remix-run+dom@0.0.0-experimental-remix-jam.6/node_modules/@remix-run/dom/dist/lib/vdom.js", "../../../../node_modules/.pnpm/@remix-run+dom@0.0.0-experimental-remix-jam.6/node_modules/@remix-run/dom/dist/lib/frame.js", "../../app/assets/entry.tsx"],
  "sourcesContent": [
    "/**\n * Use this when framework code is incorrect, indicating an internal bug rather\n * than application code error.\n */\nexport function invariant(assertion, message) {\n    let prefix = 'Framework invariant';\n    if (assertion)\n        return;\n    throw new Error(message ? `${prefix}: ${message}` : prefix);\n}\n/**\n * Use this when application logic is incorrect, indicating a developer error.\n *\n * Using ID-based warnings with external documentation links allows us to:\n * - Update warning messages without releasing new versions\n * - Avoid bloating the library with warning messages or complicating builds\n *   with prod/dev build/export shenanigans\n * - Provide detailed troubleshooting guides and examples\n *\n * `id` is first so we can easily grep the codebase for ensure calls\n */\nexport function ensure(id, assertion) {\n    if (assertion)\n        return;\n    throw new Error(`REMIX_${id}: https://rmx.as/w/${id}`);\n}\n//# sourceMappingURL=invariant.js.map",
    "import { invariant } from \"./invariant.js\";\nexport function diffDom(current, next) {\n    if (typeof next === 'string') {\n        let template = document.createElement('template');\n        template.innerHTML = next;\n        next = Array.from(template.content.childNodes);\n    }\n    diffNodes(Array.from(current), Array.from(next), {});\n}\nexport function diffNodes(curr, next, context) {\n    const parent = curr[0]?.parentNode;\n    invariant(parent, 'Parent node not found');\n    // If we're diffing a bounded region (e.g., between frame comments), we should\n    // insert new nodes before the original region's end boundary rather than\n    // appending to the end of the parent. Use the nextSibling of the last current\n    // node as a stable reference to the region's tail.\n    const regionTailRef = curr.length > 0 ? curr[curr.length - 1].nextSibling : null;\n    const max = Math.max(curr.length, next.length);\n    for (let i = 0; i < max; i++) {\n        const c = curr[i];\n        const n = next[i];\n        if (!c && n) {\n            if (regionTailRef) {\n                parent.insertBefore(n, regionTailRef);\n            }\n            else {\n                parent.appendChild(n);\n            }\n        }\n        else if (c && !n) {\n            parent.removeChild(c);\n        }\n        else if (c && n) {\n            let cursor = diffNode(c, n, context);\n            if (cursor) {\n                i = next.indexOf(cursor);\n            }\n        }\n    }\n}\nfunction diffNode(current, next, context) {\n    // Text → Text\n    if (isTextNode(current) && isTextNode(next)) {\n        const newText = next.textContent || '';\n        if (current.textContent !== newText)\n            current.textContent = newText;\n        return;\n    }\n    // VirtualRootStartMarker → VirtualRootStartMarker\n    if (isVirtualRootStartMarker(current) && isVirtualRootStartMarker(next)) {\n        let info = context.pendingRoots.get(next);\n        context.pendingRoots.delete(next);\n        invariant(info, 'missing pending virtual root info');\n        let [end, vElement] = info;\n        current.$rmx.render(vElement);\n        return end; // return cursor to fast forward\n    }\n    // Comment → Comment\n    if (isCommentNode(current) && isCommentNode(next)) {\n        const newData = next.data;\n        if (current.data !== newData)\n            current.data = newData;\n        return;\n    }\n    // Element → Element\n    if (isElement(current) && isElement(next)) {\n        // Different tags: replace\n        if (current.tagName !== next.tagName) {\n            const parent = current.parentNode;\n            if (parent)\n                parent.replaceChild(next, current);\n            return;\n        }\n        // Same tag: update attributes then children\n        diffElementAttributes(current, next, context);\n        diffElementChildren(current, next, context);\n        return;\n    }\n    // Type mismatch: replace\n    const parent = current.parentNode;\n    if (parent)\n        parent.replaceChild(next, current);\n}\nfunction diffElementAttributes(current, next, context) {\n    const prevAttrNames = current.getAttributeNames();\n    const nextAttrNames = next.getAttributeNames();\n    const nextNameSet = new Set(nextAttrNames);\n    // Removals\n    for (const name of prevAttrNames) {\n        if (!nextNameSet.has(name))\n            current.removeAttribute(name);\n    }\n    // Additions/updates\n    for (const name of nextAttrNames) {\n        const prevVal = current.getAttribute(name);\n        const nextVal = next.getAttribute(name);\n        if (prevVal !== nextVal)\n            current.setAttribute(name, nextVal == null ? '' : String(nextVal));\n    }\n}\nfunction diffElementChildren(current, next, context) {\n    const currentChildren = Array.from(current.childNodes);\n    const nextChildren = Array.from(next.childNodes);\n    // Keyed map by data-key for current children\n    const keyToIndex = new Map();\n    for (let i = 0; i < currentChildren.length; i++) {\n        const node = currentChildren[i];\n        if (isElement(node)) {\n            const key = node.getAttribute('data-key');\n            if (key != null)\n                keyToIndex.set(key, i);\n        }\n    }\n    const used = new Array(currentChildren.length).fill(false);\n    const matchIndexForNext = new Array(nextChildren.length).fill(-1);\n    for (let i = 0; i < nextChildren.length; i++) {\n        const nextChild = nextChildren[i];\n        let matchIndex = -1;\n        if (isElement(nextChild)) {\n            const key = nextChild.getAttribute('data-key');\n            if (key != null && keyToIndex.has(key)) {\n                const idx = keyToIndex.get(key);\n                if (!used[idx])\n                    matchIndex = idx;\n            }\n        }\n        if (matchIndex === -1) {\n            const candidateIndex = i;\n            if (candidateIndex < currentChildren.length &&\n                !used[candidateIndex] &&\n                nodeTypesComparable(currentChildren[candidateIndex], nextChild)) {\n                matchIndex = candidateIndex;\n            }\n        }\n        if (matchIndex !== -1)\n            used[matchIndex] = true;\n        matchIndexForNext[i] = matchIndex;\n    }\n    // Forward pass: update matched, collect committed\n    const committed = new Array(nextChildren.length);\n    for (let i = 0; i < nextChildren.length; i++) {\n        const mi = matchIndexForNext[i];\n        if (mi !== -1) {\n            const curChild = currentChildren[mi];\n            let cursor = diffNode(curChild, nextChildren[i], context);\n            if (cursor) {\n                // Fast-forward across a hydrated virtual root region.\n                const nextEndIdx = nextChildren.indexOf(cursor);\n                const currEndIdx = findHydrationEndIndex(currentChildren, mi);\n                // Mark the entire current region as used to avoid removals.\n                for (let k = mi; k <= currEndIdx; k++)\n                    used[k] = true;\n                // Preserve both boundary markers in committed; skip interior in reorder pass.\n                committed[i] = curChild; // start marker\n                committed[nextEndIdx] = currentChildren[currEndIdx]; // end marker\n                for (let j = i + 1; j < nextEndIdx; j++)\n                    committed[j] = undefined;\n                // Jump to end of region.\n                i = nextEndIdx;\n                continue;\n            }\n            committed[i] = curChild;\n        }\n        else {\n            committed[i] = nextChildren[i];\n        }\n    }\n    // Backward pass: reorder via inserts while avoiding redundant moves\n    let anchor = undefined;\n    for (let i = committed.length - 1; i >= 0; i--) {\n        const node = committed[i];\n        if (!node)\n            continue;\n        // Use only an anchor that is actually a child of the current parent\n        const ref = anchor && anchor.parentNode === current ? anchor : null;\n        // Do not move virtual-root boundary markers; keep region stable.\n        // If a boundary marker is new, ensure it is inserted before using it as an anchor.\n        if (isVirtualRootStartMarker(node) || isVirtualRootEndMarker(node)) {\n            if (node.parentNode !== current) {\n                current.insertBefore(node, ref);\n            }\n            anchor = node;\n            continue;\n        }\n        if (node.parentNode === current) {\n            // Node already in parent: move only if its nextSibling is not the desired ref.\n            const targetNext = ref;\n            const alreadyInPlace = (targetNext === null && node.nextSibling === null) || node.nextSibling === targetNext;\n            if (!alreadyInPlace) {\n                current.insertBefore(node, targetNext);\n            }\n        }\n        else {\n            // New node: insert relative to a valid ref or append\n            current.insertBefore(node, ref);\n        }\n        // Advance anchor only after the node is placed in the correct parent\n        if (node.parentNode === current) {\n            anchor = node;\n        }\n    }\n    // Removals\n    for (let i = 0; i < currentChildren.length; i++) {\n        if (!used[i]) {\n            const node = currentChildren[i];\n            if (node.parentNode === current)\n                current.removeChild(node);\n        }\n    }\n}\nfunction nodeTypesComparable(a, b) {\n    if (isTextNode(a) && isTextNode(b))\n        return true;\n    if (isElement(a) && isElement(b))\n        return a.tagName === b.tagName;\n    if (isVirtualRootStartMarker(a) && isVirtualRootStartMarker(b))\n        return true;\n    if (isVirtualRootEndMarker(a) && isVirtualRootEndMarker(b))\n        return true;\n    if (isCommentNode(a) && isCommentNode(b))\n        return true;\n    return false;\n}\nfunction isHydrationEndComment(node) {\n    return isCommentNode(node) && node.data.trim() === '/rmx:h';\n}\nfunction findHydrationEndIndex(nodes, startIdx) {\n    for (let j = startIdx + 1; j < nodes.length; j++) {\n        if (isHydrationEndComment(nodes[j]))\n            return j;\n    }\n    return startIdx;\n}\nfunction isTextNode(node) {\n    return node.nodeType === Node.TEXT_NODE;\n}\nfunction isElement(node) {\n    return node.nodeType === Node.ELEMENT_NODE;\n}\nfunction isCommentNode(node) {\n    return node.nodeType === Node.COMMENT_NODE;\n}\nfunction isVirtualRootStartMarker(node) {\n    return isCommentNode(node) && node.data.trim() === 'rmx:h';\n}\nfunction isVirtualRootEndMarker(node) {\n    return isCommentNode(node) && node.data.trim() === '/rmx:h';\n}\n//# sourceMappingURL=diff-dom.js.map",
    "let _debug = false;\nexport function debug() {\n    _debug = true;\n}\nfunction log(...args) {\n    if (_debug) {\n        console.log('DEBUG', ...args);\n    }\n}\nexport function events(target, initialDescriptors) {\n    let descriptors = [];\n    let cleanups = [];\n    let on = (nextDescriptors) => {\n        if (!nextDescriptors) {\n            nextDescriptors = [];\n        }\n        if (!Array.isArray(nextDescriptors)) {\n            nextDescriptors = [nextDescriptors];\n        }\n        if (descriptorsChanged(descriptors, nextDescriptors)) {\n            cleanupAll(cleanups);\n            cleanups = [];\n            if (nextDescriptors.length > 0) {\n                attachAllEvents(target, nextDescriptors, cleanups);\n            }\n            descriptors = nextDescriptors;\n        }\n        else {\n            updateHandlersInPlace(descriptors, nextDescriptors);\n        }\n    };\n    let cleanup = () => {\n        cleanupAll(cleanups);\n        descriptors = [];\n        cleanups = [];\n    };\n    if (initialDescriptors) {\n        on(initialDescriptors);\n        return cleanup;\n    }\n    return { on, cleanup };\n}\n/**\n * Attach a raw string event to a target. Particularly useful for custom\n * elements and web components.\n *\n * @example\n * ```ts\n * import { events, bind } from \"@remix-run/events\";\n *\n * events(target, [\n *   bind(\"custom\", event => {\n *     console.log(event.target);\n *   })\n * ])\n * ```\n */\nexport function bind(type, handler, options) {\n    return { type, handler, options };\n}\nfunction shallowEqual(a, b) {\n    if (a === b)\n        return true;\n    if (!a || !b)\n        return false;\n    if (typeof a !== 'object' || typeof b !== 'object')\n        return false;\n    let keysA = Object.keys(a);\n    let keysB = Object.keys(b);\n    if (keysA.length !== keysB.length)\n        return false;\n    for (let key of keysA) {\n        if (a[key] !== b[key])\n            return false;\n    }\n    return true;\n}\nfunction createDispatcher(target, type) {\n    return (options, originalEvent) => {\n        let customEvent = new CustomEvent(type, {\n            bubbles: true,\n            cancelable: true,\n            ...options,\n        });\n        // Patch stopPropagation to also stop the original event\n        if (originalEvent) {\n            let originalStopPropagation = customEvent.stopPropagation.bind(customEvent);\n            customEvent.stopPropagation = () => {\n                originalStopPropagation();\n                originalEvent.stopPropagation();\n            };\n        }\n        target.dispatchEvent(customEvent);\n    };\n}\nfunction prepareInteractions(target, descriptors, cleanups) {\n    // Only prepare once per unique event type (which now includes options in the name)\n    let seenEventTypes = new Set();\n    for (let descriptor of descriptors) {\n        if (seenEventTypes.has(descriptor.type)) {\n            continue; // Skip if we've already prepared this event type\n        }\n        seenEventTypes.add(descriptor.type);\n        let dispatch = createDispatcher(target, descriptor.type);\n        let factoryResult = descriptor.factory({ dispatch, target }, descriptor.factoryOptions);\n        if (factoryResult) {\n            let factoryCleanups = Array.isArray(factoryResult) ? factoryResult : [factoryResult];\n            cleanups.push(...factoryCleanups);\n        }\n    }\n}\nfunction attach(target, eventType, descriptors, cleanups) {\n    log('attach', { target, eventType, descriptors });\n    let preventedEvents = new Set();\n    for (let descriptor of descriptors) {\n        let controller = new AbortController();\n        let wrappedHandler = (event) => {\n            controller.abort(new DOMException('Handler reentered', 'EventReentry'));\n            controller = new AbortController();\n            log('wrappedHandler', { target, eventType, event });\n            if (preventedEvents.has(event)) {\n                log('prevented', { target, eventType, event });\n                return;\n            }\n            let call = descriptor.handler(event, controller.signal);\n            if (call instanceof Promise) {\n                call.catch((e) => {\n                    if (e instanceof DOMException && e.name === 'EventReentry') {\n                        // swallow\n                    }\n                    else {\n                        throw e;\n                    }\n                });\n            }\n            if (event.defaultPrevented) {\n                preventedEvents.add(event);\n                setTimeout(() => preventedEvents.delete(event), 0);\n            }\n        };\n        target.addEventListener(eventType, wrappedHandler, descriptor.options);\n        cleanups.push(() => {\n            controller.abort();\n            target.removeEventListener(eventType, wrappedHandler, descriptor.options);\n        });\n    }\n}\nfunction attachStandardEvents(target, descriptors, cleanups) {\n    let eventsByType = new Map();\n    for (let descriptor of descriptors) {\n        if (!eventsByType.has(descriptor.type)) {\n            eventsByType.set(descriptor.type, []);\n        }\n        eventsByType.get(descriptor.type).push(descriptor);\n    }\n    for (let [type, descriptors] of eventsByType) {\n        attach(target, type, descriptors, cleanups);\n    }\n}\nfunction attachInteractions(target, descriptors, cleanups) {\n    let byType = new Map();\n    for (let descriptor of descriptors) {\n        if (!byType.has(descriptor.type)) {\n            byType.set(descriptor.type, []);\n        }\n        byType.get(descriptor.type).push(descriptor);\n    }\n    for (let [type, descriptors] of byType) {\n        attach(target, type, descriptors, cleanups);\n    }\n}\nfunction attachAllEvents(target, descriptors, cleanups) {\n    let { custom, standard } = splitDescriptors(descriptors);\n    prepareInteractions(target, custom, cleanups);\n    attachInteractions(target, custom, cleanups);\n    attachStandardEvents(target, standard, cleanups);\n}\nfunction splitDescriptors(descriptors) {\n    let custom = [];\n    let standard = [];\n    for (let descriptor of descriptors) {\n        if (isInteractionDescriptor(descriptor)) {\n            custom.push(descriptor);\n        }\n        else {\n            standard.push(descriptor);\n        }\n    }\n    return { custom, standard };\n}\nfunction isInteractionDescriptor(descriptor) {\n    return descriptor.isCustom === true;\n}\nfunction descriptorsChanged(descriptors, nextDescriptors) {\n    if (descriptors.length !== nextDescriptors.length) {\n        return true;\n    }\n    for (let i = 0; i < descriptors.length; i++) {\n        let current = descriptors[i];\n        let next = nextDescriptors[i];\n        if (current.type !== next.type ||\n            current.isCustom !== next.isCustom ||\n            !shallowEqual(current.options, next.options) ||\n            !shallowEqual(current.factoryOptions, next.factoryOptions)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction updateHandlersInPlace(descriptors, nextDescriptors) {\n    for (let i = 0; i < nextDescriptors.length; i++) {\n        descriptors[i].handler = nextDescriptors[i].handler;\n    }\n}\nfunction cleanupAll(cleanups) {\n    for (let cleanup of cleanups)\n        cleanup();\n}\n//# sourceMappingURL=events.js.map",
    "import { bind } from \"./events.js\";\nexport function createTargetProxy() {\n    return new Proxy(function targetFunction(type, handler, options) {\n        return bind(type, handler, options);\n    }, {\n        get(target, prop) {\n            if (typeof prop === 'string') {\n                return function (handler, options) {\n                    return bind(prop, handler, options);\n                };\n            }\n            return target[prop];\n        },\n    });\n}\nexport let dom = createTargetProxy();\nexport let xhr = createTargetProxy();\nexport let win = createTargetProxy();\nexport let doc = createTargetProxy();\nexport let ws = createTargetProxy();\n//# sourceMappingURL=targets.js.map",
    "export function createEventType(eventName) {\n    let binder = (handler, options) => {\n        return {\n            type: eventName,\n            handler: handler,\n            options,\n        };\n    };\n    let createEvent = (...args) => {\n        let init = args[0];\n        return new CustomEvent(eventName, {\n            bubbles: true,\n            cancelable: true,\n            ...init,\n        });\n    };\n    return [binder, createEvent];\n}\n//# sourceMappingURL=event-type.js.map",
    "// Style processing and CSS-in-JS system\n// Convert camelCase CSS properties to kebab-case\nfunction camelToKebab(str) {\n    return str.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`);\n}\n// Check if a style property is a nested selector or media query\nfunction isComplexSelector(key) {\n    return (key.startsWith('&') ||\n        key.startsWith('@') ||\n        key.startsWith(':') ||\n        key.startsWith('[') ||\n        key.startsWith('.'));\n}\n// Detect @keyframes (including vendor-prefixed variants)\nfunction isKeyframesAtRule(key) {\n    if (!key.startsWith('@'))\n        return false;\n    let lower = key.toLowerCase();\n    return (lower.startsWith('@keyframes') ||\n        lower.startsWith('@-webkit-keyframes') ||\n        lower.startsWith('@-moz-keyframes') ||\n        lower.startsWith('@-o-keyframes'));\n}\n// Generate a hash for style objects to create unique class names\nfunction hashStyle(obj) {\n    // Sort keys to ensure consistent hashing, but include values in the string\n    let sortedEntries = Object.entries(obj).sort(([a], [b]) => a.localeCompare(b));\n    let str = JSON.stringify(sortedEntries);\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        let char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash; // Convert to 32-bit integer\n    }\n    return Math.abs(hash).toString(36);\n}\n// Convert style object to CSS text\nfunction styleToCss(styles, selector = '') {\n    let baseDeclarations = [];\n    let nestedBlocks = [];\n    let atRules = [];\n    let preludeAtRules = [];\n    for (let [key, value] of Object.entries(styles)) {\n        if (isComplexSelector(key)) {\n            if (key.startsWith('@')) {\n                // Some at-rules (e.g., @media) scope declarations to the selector.\n                // Others (e.g., @function) must NOT include the selector in their body.\n                if (key.startsWith('@function')) {\n                    let body = atRuleBodyToCss(value);\n                    if (body.trim().length > 0) {\n                        preludeAtRules.push(`${key} {\\n${indent(body, 2)}\\n}`);\n                    }\n                    else {\n                        preludeAtRules.push(`${key} {\\n}`);\n                    }\n                }\n                else if (isKeyframesAtRule(key)) {\n                    // Keyframes definitions must not be wrapped with the element selector.\n                    // Emit them before the class rule so animations can be referenced.\n                    let body = keyframesBodyToCss(value);\n                    if (body.trim().length > 0) {\n                        preludeAtRules.push(`${key} {\\n${indent(body, 2)}\\n}`);\n                    }\n                    else {\n                        preludeAtRules.push(`${key} {\\n}`);\n                    }\n                }\n                else {\n                    // Default: keep at-rules nested with the element selector\n                    let inner = styleToCss(value, selector);\n                    if (inner.trim().length > 0) {\n                        atRules.push(`${key} {\\n${indent(inner, 2)}\\n}`);\n                    }\n                    else {\n                        // Empty at-rule body with selector block\n                        atRules.push(`${key} {\\n  ${selector} {\\n  }\\n}`);\n                    }\n                }\n                continue;\n            }\n            // For nested selectors, keep them wholesale inside the base block\n            let nestedContent = '';\n            for (let [prop, propValue] of Object.entries(value)) {\n                if (propValue != null) {\n                    nestedContent += `    ${camelToKebab(prop)}: ${propValue};\\n`;\n                }\n            }\n            if (nestedContent) {\n                // Preserve key verbatim (e.g., '&[aria-selected], &[rmx-focus]')\n                nestedBlocks.push(`  ${key} {\\n${nestedContent}  }`);\n            }\n        }\n        else {\n            // Base declaration\n            if (value != null) {\n                baseDeclarations.push(`  ${camelToKebab(key)}: ${value};`);\n            }\n        }\n    }\n    let css = '';\n    if (preludeAtRules.length > 0) {\n        css += preludeAtRules.join('\\n');\n    }\n    if (selector && (baseDeclarations.length > 0 || nestedBlocks.length > 0)) {\n        css += (css ? '\\n' : '') + `${selector} {\\n`;\n        if (baseDeclarations.length > 0) {\n            css += baseDeclarations.join('\\n') + '\\n';\n        }\n        if (nestedBlocks.length > 0) {\n            css += nestedBlocks.join('\\n') + '\\n';\n        }\n        css += '}';\n    }\n    if (atRules.length > 0) {\n        css += (css ? '\\n' : '') + atRules.join('\\n');\n    }\n    return css;\n}\nfunction indent(text, spaces) {\n    let pad = ' '.repeat(spaces);\n    return text\n        .split('\\n')\n        .map((line) => (line.length ? pad + line : line))\n        .join('\\n');\n}\n// Narrow unknown values to plain record objects\nfunction isRecord(value) {\n    return typeof value === 'object' && value !== null;\n}\n// Build the body of a @keyframes rule (without wrapping selector)\nfunction keyframesBodyToCss(frames) {\n    if (!isRecord(frames))\n        return '';\n    let blocks = [];\n    for (let [frameSelector, frameValue] of Object.entries(frames)) {\n        if (!isRecord(frameValue)) {\n            // Skip non-object frame definitions\n            continue;\n        }\n        let declarations = [];\n        for (let [prop, propValue] of Object.entries(frameValue)) {\n            if (propValue == null)\n                continue;\n            // Ignore nested selectors/at-rules inside keyframe steps\n            if (isComplexSelector(prop))\n                continue;\n            declarations.push(`  ${camelToKebab(prop)}: ${propValue};`);\n        }\n        if (declarations.length > 0) {\n            blocks.push(`${frameSelector} {\\n${declarations.join('\\n')}\\n}`);\n        }\n        else {\n            blocks.push(`${frameSelector} {\\n}`);\n        }\n    }\n    return blocks.join('\\n');\n}\n// Build the body for at-rules that should not include a selector wrapper (e.g., @function)\nfunction atRuleBodyToCss(styles) {\n    let declarations = [];\n    let nested = [];\n    for (let [key, value] of Object.entries(styles)) {\n        if (isComplexSelector(key)) {\n            if (key.startsWith('@')) {\n                // Nested at-rules inside definition blocks; render their bodies recursively without selectors\n                let inner = atRuleBodyToCss(value);\n                if (inner.trim().length > 0) {\n                    nested.push(`${key} {\\n${indent(inner, 2)}\\n}`);\n                }\n                else {\n                    nested.push(`${key} {\\n}`);\n                }\n            }\n            else {\n                // Ignore nested selectors (&, :, ., [) inside definition-style at-rules\n                // They are not meaningful within e.g. @function bodies\n                continue;\n            }\n        }\n        else {\n            if (value != null) {\n                declarations.push(`  ${camelToKebab(key)}: ${value};`);\n            }\n        }\n    }\n    let body = '';\n    if (declarations.length > 0) {\n        body += declarations.join('\\n');\n    }\n    if (nested.length > 0) {\n        body += (body ? '\\n' : '') + nested.join('\\n');\n    }\n    return body;\n}\n// Process style prop and return class name and CSS\nexport function processStyle(styleObj, styleCache) {\n    // Check if the object is empty\n    if (Object.keys(styleObj).length === 0) {\n        return { className: '', css: '' };\n    }\n    // Always extract to CSS class, even for simple styles\n    let hash = hashStyle(styleObj);\n    let className = `rmx-${hash}`;\n    // Check cache first\n    let cached = styleCache.get(hash);\n    if (cached) {\n        return cached;\n    }\n    // Generate CSS\n    let css = styleToCss(styleObj, `.${className}`);\n    let result = { className, css };\n    // Store in cache\n    styleCache.set(hash, result);\n    return result;\n}\n// Clear style cache (useful for testing)\nexport function clearStyleCache(styleCache) {\n    styleCache.clear();\n}\n//# sourceMappingURL=style.js.map",
    "export function createStyleManager(layer = 'rmx') {\n    let stylesheet = new CSSStyleSheet();\n    document.adoptedStyleSheets.push(stylesheet);\n    // Track usage count per className\n    let counts = new Map();\n    let inserted = new Set();\n    function has(className) {\n        return counts.has(className);\n    }\n    function insert(className, rule) {\n        if (inserted.has(className))\n            return;\n        inserted.add(className);\n        // let current = counts.get(className) || 0\n        // if (current > 0) {\n        //   counts.set(className, current + 1)\n        //   return\n        // }\n        stylesheet.insertRule(`@layer ${layer} { ${rule} }`);\n        // counts.set(className, 1)\n    }\n    // DEBUGGING - so no removals right now\n    function remove(className) {\n        // let current = counts.get(className)\n        // if (!current) return\n        // if (current > 1) {\n        //   counts.set(className, current - 1)\n        //   return\n        // }\n        // // fully remove\n        // counts.delete(className)\n        // // find the rule index containing this class and delete it\n        // for (let i = 0; i < stylesheet.cssRules.length; i++) {\n        //   let text = (stylesheet.cssRules[i] as any).cssText || ''\n        //   if (text.includes(`.${className}`)) {\n        //     stylesheet.deleteRule(i)\n        //     break\n        //   }\n        // }\n    }\n    return { insert, remove, has };\n}\n/*\nlet manager = createStyleManager()\nmanager.insert(\"rmx-123\", \".rmx-123 { color: red; }\")\nmanager.remove(\"rmx-123\")\n*/\n//# sourceMappingURL=stylesheet.js.map",
    "import { createEventType, events, } from '@remix-run/events';\nimport { createComponent, Catch, Fragment, Frame, createFrameHandle } from \"./component.js\";\nimport { invariant } from \"./invariant.js\";\nimport { processStyle, createStyleManager } from '@remix-run/style';\nlet fixmeIdCounter = 0;\nconst TEXT_NODE = Symbol('TEXT_NODE');\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\nconst XML_NS = 'http://www.w3.org/XML/1998/namespace';\nlet [connect, createConnectEvent] = createEventType('rmx:connect');\nlet [disconnect, createDisconnectEvent] = createEventType('rmx:disconnect');\nexport { connect, disconnect };\n// global so all roots share it\nlet styleCache = new Map();\nlet styleManager = typeof window !== 'undefined'\n    ? createStyleManager()\n    : null;\nexport function createScheduler() {\n    let scheduled = new Map();\n    let tasks = [];\n    // TODO: optimize. this is O(k*h), should avoid climbing the tree for already\n    // visited intermediate nodes\n    function ancestorIsScheduled(vnode, batch) {\n        let current = vnode._parent;\n        while (current) {\n            if (isCommittedComponentNode(current) && batch.has(current))\n                return true;\n            current = current._parent;\n        }\n        return false;\n    }\n    return {\n        enqueue(vnode, domParent, anchor) {\n            scheduled.set(vnode, [domParent, anchor]);\n            queueMicrotask(() => this.dequeue());\n        },\n        enqueueTasks(newTasks) {\n            tasks.push(...newTasks);\n            queueMicrotask(() => this.dequeue());\n        },\n        dequeue() {\n            let batch = new Map(scheduled);\n            scheduled.clear();\n            if (batch.size > 0) {\n                let vnodes = Array.from(batch);\n                for (let [vnode, [domParent, anchor]] of vnodes) {\n                    if (ancestorIsScheduled(vnode, batch))\n                        continue;\n                    let handle = vnode._handle;\n                    let curr = vnode._content;\n                    let vParent = vnode._parent;\n                    renderComponent(handle, curr, vnode, domParent, handle.frame, this, vParent, anchor);\n                }\n            }\n            if (tasks.length > 0) {\n                for (let task of tasks) {\n                    task();\n                }\n                tasks = [];\n            }\n        },\n    };\n}\nconst ROOT_VNODE = Symbol('ROOT_VNODE');\nexport function createRangeRoot([start, end], options = {}) {\n    let root = null;\n    let frameStub = options.frame ?? createFrameHandle();\n    let scheduler = options.scheduler ?? createScheduler();\n    let container = end.parentNode;\n    invariant(container, 'Expected parent node');\n    invariant(end.parentNode === container, 'Boundaries must share parent');\n    let hydrationCursor = start.nextSibling;\n    return {\n        render(element) {\n            let vnode = toVNode(element);\n            let vParent = { type: ROOT_VNODE };\n            diffVNodes(root, vnode, container, frameStub, scheduler, vParent, end, hydrationCursor);\n            root = vnode;\n            hydrationCursor = null;\n        },\n        remove() {\n            root = null;\n        },\n        flush() {\n            scheduler.dequeue();\n        },\n    };\n}\nexport function createRoot(container, options = {}) {\n    let root = null;\n    let frameStub = options.frame ?? createFrameHandle();\n    let scheduler = options.scheduler ?? createScheduler();\n    let hydrationCursor = container.innerHTML.trim() !== '' ? container.firstChild : undefined;\n    return {\n        render(element) {\n            let vnode = toVNode(element);\n            let vParent = { type: ROOT_VNODE };\n            diffVNodes(root, vnode, container, frameStub, scheduler, vParent, undefined, hydrationCursor);\n            root = vnode;\n            hydrationCursor = undefined;\n        },\n        remove() {\n            root = null;\n        },\n        flush() {\n            scheduler.dequeue();\n        },\n    };\n}\nfunction flatMapChildrenToVNodes(node) {\n    return 'children' in node.props\n        ? Array.isArray(node.props.children)\n            ? node.props.children.flat(Infinity).map(toVNode)\n            : [toVNode(node.props.children)]\n        : [];\n}\nexport function toVNode(node) {\n    if (node === null || node === undefined || typeof node === 'boolean') {\n        return { type: TEXT_NODE, _text: '' };\n    }\n    if (typeof node === 'string' || typeof node === 'number' || typeof node === 'bigint') {\n        return { type: TEXT_NODE, _text: String(node) };\n    }\n    if (Array.isArray(node)) {\n        return { type: Fragment, _children: node.flat(Infinity).map(toVNode) };\n    }\n    if (node.type === Fragment) {\n        return { type: Fragment, _children: flatMapChildrenToVNodes(node) };\n    }\n    if (node.type === Catch) {\n        return {\n            type: Catch,\n            _fallback: node.props.fallback,\n            _children: flatMapChildrenToVNodes(node),\n        };\n    }\n    if (isRemixElement(node)) {\n        let children = flatMapChildrenToVNodes(node);\n        return { type: node.type, props: node.props, _children: children };\n    }\n    invariant(false, 'Unexpected RemixNode');\n}\nexport function diffVNodes(curr, next, domParent, frame, scheduler, vParent, anchor, rootCursor) {\n    next._parent = vParent; // set parent for initial render context lookups\n    // new\n    if (curr === null) {\n        insert(next, domParent, frame, scheduler, vParent, anchor, rootCursor);\n        return;\n    }\n    if (curr.type !== next.type) {\n        replace(curr, next, domParent, frame, scheduler, vParent, anchor);\n        return;\n    }\n    if (isCommittedTextNode(curr) && isTextNode(next)) {\n        diffText(curr, next, scheduler, vParent);\n        return;\n    }\n    if (isCommittedHostNode(curr) && isHostNode(next)) {\n        diffHost(curr, next, domParent, frame, scheduler, vParent);\n        return;\n    }\n    if (isCommittedComponentNode(curr) && isComponentNode(next)) {\n        diffComponent(curr, next, frame, scheduler, domParent, vParent);\n        return;\n    }\n    if (isFragmentNode(curr) && isFragmentNode(next)) {\n        diffChildren(curr._children, next._children, domParent, frame, scheduler, vParent, undefined, anchor);\n        return;\n    }\n    if (isCatchNode(curr) && isCatchNode(next)) {\n        diffCatch(curr, next, domParent, frame, scheduler, vParent);\n        return;\n    }\n    if (curr.type === Frame && next.type === Frame) {\n        throw new Error('TODO: Frame diff not implemented');\n    }\n    invariant(false, 'Unexpected diff case');\n}\nfunction diffCatch(curr, next, domParent, frame, scheduler, vParent) {\n    if (curr._tripped) {\n        replace(curr, next, domParent, frame, scheduler, vParent);\n        return;\n    }\n    let added = [];\n    try {\n        for (let i = 0; i < curr._children.length; i++) {\n            let child = curr._children[i];\n            diffVNodes(child, next._children[i], domParent, frame, scheduler, vParent);\n            added.unshift(child);\n        }\n        commitCatch(curr, { _parent: vParent, _tripped: false, _added: added });\n    }\n    catch (e) {\n        for (let child of added) {\n            remove(child, domParent, scheduler);\n        }\n        let fallbackNode = getCatchFallback(next, e);\n        let anchor = findFirstDomAnchor(curr) || findNextSiblingDomAnchor(curr, vParent) || undefined;\n        insert(fallbackNode, domParent, frame, scheduler, vParent, anchor);\n        commitCatch(curr, { _parent: vParent, _tripped: true, _added: [fallbackNode] });\n        dispatchError(e);\n    }\n}\nfunction replace(curr, next, domParent, frame, scheduler, vParent, anchor) {\n    anchor =\n        anchor || findFirstDomAnchor(curr) || findNextSiblingDomAnchor(curr, vParent) || undefined;\n    insert(next, domParent, frame, scheduler, vParent, anchor);\n    remove(curr, domParent, scheduler);\n}\nfunction diffHost(curr, next, domParent, frame, scheduler, vParent) {\n    diffChildren(curr._children, next._children, curr._dom, frame, scheduler, next);\n    diffHostProps(curr.props, next.props, curr._dom);\n    let extras = { _dom: curr._dom, _parent: vParent, _events: curr._events };\n    commitHost(next, extras, scheduler, domParent, frame);\n    return;\n}\nfunction diffCssProp(curr, next, dom) {\n    let prevClassName = curr.css ? processStyle(curr.css, styleCache).className : '';\n    let { className, css } = next.css\n        ? processStyle(next.css, styleCache)\n        : { className: '', css: '' };\n    if (prevClassName === className)\n        return;\n    if (prevClassName) {\n        dom.classList.remove(prevClassName);\n        styleManager.remove(prevClassName);\n    }\n    if (css && className) {\n        dom.classList.add(className);\n        styleManager.insert(className, css);\n    }\n}\nfunction diffHostProps(curr, next, dom) {\n    let isSvg = dom.namespaceURI === SVG_NS;\n    if (next.css || curr.css) {\n        diffCssProp(curr, next, dom);\n    }\n    // Removals\n    for (let name in curr) {\n        if (isFrameworkProp(name))\n            continue;\n        if (!(name in next) || next[name] == null) {\n            // Prefer property clearing when applicable (align with Preact)\n            if (canUseProperty(dom, name, isSvg)) {\n                try {\n                    dom[name] = '';\n                    continue;\n                }\n                catch { }\n            }\n            let { ns, attr } = normalizePropName(name, isSvg);\n            if (ns)\n                dom.removeAttributeNS(ns, attr);\n            else\n                dom.removeAttribute(attr);\n        }\n    }\n    // Additions/updates\n    for (let name in next) {\n        if (isFrameworkProp(name))\n            continue;\n        let nextValue = next[name];\n        if (nextValue == null)\n            continue;\n        let prevValue = curr[name];\n        if (prevValue !== nextValue) {\n            let { ns, attr } = normalizePropName(name, isSvg);\n            // Object style: serialize to attribute for now\n            if (attr === 'style' &&\n                typeof nextValue === 'object' &&\n                nextValue &&\n                !Array.isArray(nextValue)) {\n                dom.setAttribute('style', serializeStyleObject(nextValue));\n                continue;\n            }\n            // Prefer property assignment when possible (HTML only, not SVG)\n            if (canUseProperty(dom, name, isSvg)) {\n                try {\n                    dom[name] = nextValue == null ? '' : nextValue;\n                    continue;\n                }\n                catch { }\n            }\n            // Attribute path\n            if (typeof nextValue === 'function') {\n                // Never serialize functions as attribute values\n                continue;\n            }\n            let isAriaOrData = name.startsWith('aria-') || name.startsWith('data-');\n            if (nextValue != null && (nextValue !== false || isAriaOrData)) {\n                // Special-case popover: true => presence only\n                let attrValue = name === 'popover' && nextValue === true ? '' : String(nextValue);\n                if (ns)\n                    dom.setAttributeNS(ns, attr, attrValue);\n                else\n                    dom.setAttribute(attr, attrValue);\n            }\n            else {\n                if (ns)\n                    dom.removeAttributeNS(ns, attr);\n                else\n                    dom.removeAttribute(attr);\n            }\n        }\n    }\n}\n// Preact excludes certain attributes from the property path due to browser quirks\nconst ATTRIBUTE_FALLBACK_NAMES = new Set([\n    'width',\n    'height',\n    'href',\n    'list',\n    'form',\n    'tabIndex',\n    'download',\n    'rowSpan',\n    'colSpan',\n    'role',\n    'popover',\n]);\n// Determine if we should use the property path for a given name.\n// Also acts as a type guard to allow bracket assignment without casts.\nfunction canUseProperty(dom, name, isSvg) {\n    if (isSvg)\n        return false;\n    if (ATTRIBUTE_FALLBACK_NAMES.has(name))\n        return false;\n    return name in dom;\n}\nfunction isCommittedCatchNode(node) {\n    return isCatchNode(node) && node._added != undefined && node._tripped != null;\n}\nfunction isComponentNode(node) {\n    return typeof node.type === 'function' && node.type !== Frame;\n}\nfunction isCommittedComponentNode(node) {\n    return isComponentNode(node) && node._content !== undefined;\n}\nfunction isFrameworkProp(name) {\n    return name === 'children' || name === 'key' || name === 'on' || name === 'css';\n}\nconst NUMERIC_CSS_PROPS = new Set([\n    'z-index',\n    'opacity',\n    'flex-grow',\n    'flex-shrink',\n    'flex-order',\n    'grid-area',\n    'grid-row',\n    'grid-column',\n    'font-weight',\n    'line-height',\n    'order',\n    'orphans',\n    'widows',\n    'zoom',\n    'columns',\n    'column-count',\n]);\n// TODO: would rather actually diff el.style object directly instead of writing\n// to the style attribute\nfunction serializeStyleObject(style) {\n    let parts = [];\n    for (let [key, value] of Object.entries(style)) {\n        if (value == null)\n            continue;\n        if (typeof value === 'boolean')\n            continue;\n        if (typeof value === 'number' && !Number.isFinite(value))\n            continue;\n        let cssKey = key.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);\n        let shouldAppendPx = typeof value === 'number' &&\n            value !== 0 &&\n            !NUMERIC_CSS_PROPS.has(cssKey) &&\n            !cssKey.startsWith('--');\n        let cssValue = shouldAppendPx\n            ? `${value}px`\n            : Array.isArray(value)\n                ? value.join(', ')\n                : String(value);\n        parts.push(`${cssKey}: ${cssValue};`);\n    }\n    return parts.join(' ');\n}\nfunction isSvgContext(vParent) {\n    // Walk up the vnode tree to determine if we're within an SVG subtree.\n    // The nearest 'foreignObject' switches back to HTML context.\n    let current = vParent;\n    while (current) {\n        if (typeof current.type === 'string') {\n            if (current.type === 'foreignObject')\n                return false;\n            if (current.type === 'svg')\n                return true;\n        }\n        current = current._parent;\n    }\n    return false;\n}\nfunction normalizePropName(name, isSvg) {\n    // aria-/data- pass through\n    if (name.startsWith('aria-') || name.startsWith('data-'))\n        return { attr: name };\n    // DOM property -> HTML mappings\n    if (!isSvg) {\n        if (name === 'className')\n            return { attr: 'class' };\n        if (name === 'htmlFor')\n            return { attr: 'for' };\n        if (name === 'tabIndex')\n            return { attr: 'tabindex' };\n        if (name === 'acceptCharset')\n            return { attr: 'accept-charset' };\n        if (name === 'httpEquiv')\n            return { attr: 'http-equiv' };\n        return { attr: name.toLowerCase() };\n    }\n    // SVG namespaced specials\n    if (name === 'xlinkHref')\n        return { ns: XLINK_NS, attr: 'xlink:href' };\n    if (name === 'xmlLang')\n        return { ns: XML_NS, attr: 'xml:lang' };\n    if (name === 'xmlSpace')\n        return { ns: XML_NS, attr: 'xml:space' };\n    // SVG preserved-case exceptions\n    if (name === 'viewBox' ||\n        name === 'preserveAspectRatio' ||\n        name === 'gradientUnits' ||\n        name === 'gradientTransform' ||\n        name === 'patternUnits' ||\n        name === 'patternTransform' ||\n        name === 'clipPathUnits' ||\n        name === 'maskUnits' ||\n        name === 'maskContentUnits') {\n        return { attr: name };\n    }\n    // General SVG: kebab-case\n    return { attr: camelToKebab(name) };\n}\nfunction camelToKebab(input) {\n    return input\n        .replace(/([a-z0-9])([A-Z])/g, '$1-$2')\n        .replace(/_/g, '-')\n        .toLowerCase();\n}\nfunction diffText(curr, next, scheduler, vParent) {\n    if (curr._text !== next._text) {\n        curr._dom.textContent = next._text;\n    }\n    commitText(next, { _dom: curr._dom, _parent: vParent });\n}\nfunction logHydrationMismatch(...msg) {\n    console.error('Hydration mismatch:', ...msg);\n}\nfunction insert(node, domParent, frame, scheduler, vParent, anchor, cursor) {\n    node._parent = vParent; // set parent for initial render context lookups\n    cursor = skipComments(cursor ?? null);\n    let doInsert = anchor\n        ? (dom) => domParent.insertBefore(dom, anchor)\n        : (dom) => domParent.appendChild(dom);\n    if (isTextNode(node)) {\n        if (cursor instanceof Text) {\n            commitText(node, { _dom: cursor, _parent: vParent });\n            // correct hydration mismatch\n            if (cursor.data !== node._text) {\n                logHydrationMismatch('text mismatch', cursor.data, node._text);\n                cursor.data = node._text;\n            }\n            return cursor.nextSibling;\n        }\n        let dom = document.createTextNode(node._text);\n        commitText(node, { _dom: dom, _parent: vParent });\n        doInsert(dom);\n        return cursor;\n    }\n    if (isHostNode(node)) {\n        if (cursor instanceof Element) {\n            if (cursor.tagName.toLowerCase() === node.type) {\n                // FIXME: hydrate css prop\n                // correct hydration mismatches\n                diffHostProps({}, node.props, cursor);\n                commitHost(node, { _dom: cursor, _parent: vParent }, scheduler, domParent, frame);\n                let childCursor = cursor.firstChild;\n                // FIXME: this breaks other tests\n                // if (node._children.length > 1 && node._children.every(isTextNode)) {\n                //   // special case <span>Text {text}</span> comes as single node from server\n                //   return cursor.nextSibling\n                // }\n                let excess = diffChildren(null, node._children, cursor, frame, scheduler, node, childCursor);\n                if (excess) {\n                    logHydrationMismatch('excess', excess);\n                }\n                return cursor.nextSibling;\n            }\n            else {\n                logHydrationMismatch('tag', cursor.tagName.toLowerCase(), node.type);\n                cursor.remove();\n                cursor = undefined; // stop hydration for this tree\n            }\n        }\n        let inSvg = isSvgContext(vParent) || node.type === 'svg';\n        let dom = inSvg\n            ? document.createElementNS(SVG_NS, node.type)\n            : document.createElement(node.type);\n        diffHostProps({}, node.props, dom);\n        diffChildren(null, node._children, dom, frame, scheduler, node);\n        commitHost(node, { _dom: dom, _parent: vParent }, scheduler, domParent, frame);\n        doInsert(dom);\n        return cursor;\n    }\n    if (isFragmentNode(node)) {\n        // Insert fragment children in order before the same anchor\n        for (let child of node._children) {\n            cursor = insert(child, domParent, frame, scheduler, vParent, anchor, cursor);\n        }\n        return cursor;\n    }\n    if (isCatchNode(node)) {\n        let added = [];\n        try {\n            // insert like a fragment\n            for (let child of node._children) {\n                insert(child, domParent, frame, scheduler, node, anchor);\n                added.unshift(child);\n            }\n            commitCatch(node, { _parent: vParent, _tripped: false, _added: added });\n        }\n        catch (e) {\n            let fallback = getCatchFallback(node, e);\n            for (let child of added) {\n                remove(child, domParent, scheduler);\n            }\n            insert(fallback, domParent, frame, scheduler, node, anchor);\n            commitCatch(node, { _parent: vParent, _tripped: true, _added: [fallback] });\n            dispatchError(e);\n        }\n        return;\n    }\n    if (isComponentNode(node)) {\n        diffComponent(null, node, frame, scheduler, domParent, vParent, anchor, cursor);\n        return cursor;\n    }\n    if (node.type === Frame) {\n        throw new Error('TODO: Frame insert not implemented');\n    }\n    if (node.type === Catch) {\n        throw new Error('TODO: Catch insert not implemented');\n    }\n    invariant(false, 'Unexpected node type');\n}\nfunction renderComponent(handle, currContent, next, domParent, frame, scheduler, vParent, anchor, cursor) {\n    let normalizedOn = next.props.on\n        ? Array.isArray(next.props.on)\n            ? next.props.on\n            : [next.props.on]\n        : undefined;\n    let props = normalizedOn ? { ...next.props, on: normalizedOn } : next.props;\n    let [element, tasks] = handle.render(props);\n    let content = toVNode(element);\n    diffVNodes(currContent, content, domParent, frame, scheduler, next, anchor, cursor);\n    let committed = commitComponent(next, { _content: content, _handle: handle, _parent: vParent });\n    handle.setScheduleUpdate(() => {\n        scheduler.enqueue(committed, domParent, anchor);\n    });\n    scheduler.enqueueTasks(tasks);\n}\nfunction diffComponent(curr, next, frame, scheduler, domParent, vParent, anchor, cursor) {\n    if (curr === null) {\n        next._handle = createComponent({\n            id: String(++fixmeIdCounter),\n            frame,\n            type: next.type,\n            raise: (error) => {\n                raise(error, next, domParent, frame, scheduler);\n            },\n            getContext: (type) => {\n                return findContextFromAncestry(vParent, type);\n            },\n        });\n        renderComponent(next._handle, null, next, domParent, frame, scheduler, vParent, anchor, cursor);\n        return;\n    }\n    next._handle = curr._handle;\n    let { _content, _handle } = curr;\n    renderComponent(_handle, _content, next, domParent, frame, scheduler, vParent, anchor, cursor);\n}\nfunction findContextFromAncestry(node, type) {\n    let current = node;\n    while (current) {\n        if (current.type === type && isComponentNode(current)) {\n            return current._handle.getContextValue();\n        }\n        current = current._parent;\n    }\n    return undefined;\n}\nfunction remove(node, domParent, scheduler) {\n    if (isCommittedTextNode(node)) {\n        domParent.removeChild(node._dom);\n        return;\n    }\n    if (isCommittedHostNode(node)) {\n        node._dom.dispatchEvent(createDisconnectEvent({ bubbles: false }));\n        domParent.removeChild(node._dom);\n        let _events = node._events;\n        if (_events) {\n            // TODO: use abort controllers in @remix-run/events, won't need to manage cleanup\n            scheduler.enqueueTasks([() => _events.cleanup()]);\n        }\n        return;\n    }\n    if (isFragmentNode(node)) {\n        for (let child of node._children) {\n            remove(child, domParent, scheduler);\n        }\n        return;\n    }\n    if (isCommittedComponentNode(node)) {\n        remove(node._content, domParent, scheduler);\n        let tasks = node._handle.remove();\n        scheduler.enqueueTasks(tasks);\n        return;\n    }\n    if (isFragmentNode(node)) {\n        for (let child of node._children) {\n            remove(child, domParent, scheduler);\n        }\n        return;\n    }\n    if (isCommittedCatchNode(node)) {\n        for (let child of node._added) {\n            remove(child, domParent, scheduler);\n        }\n        return;\n    }\n}\n// TODO: optimize later\nfunction diffChildren(curr, next, domParent, frame, scheduler, vParent, cursor, anchor) {\n    if (curr === null) {\n        for (let node of next) {\n            cursor = insert(node, domParent, frame, scheduler, vParent, anchor, cursor);\n        }\n        return cursor;\n    }\n    let currLength = curr.length;\n    let nextLength = next.length;\n    for (let i = 0; i < nextLength; i++) {\n        let currentNode = i < currLength ? curr[i] : null;\n        diffVNodes(currentNode, next[i], domParent, frame, scheduler, vParent, anchor, cursor);\n    }\n    if (currLength > nextLength) {\n        for (let i = nextLength; i < currLength; i++) {\n            let node = curr[i];\n            if (node)\n                remove(node, domParent, scheduler);\n        }\n    }\n}\nfunction commitText(node, extras) {\n    return Object.assign(node, extras);\n}\nfunction commitComponent(node, extras) {\n    return Object.assign(node, extras);\n}\nfunction commitCatch(node, extras) {\n    return Object.assign(node, extras);\n}\nfunction commitHost(node, extras, scheduler, domParent, frame) {\n    let _dom = extras._dom;\n    let _events = extras._events || events(_dom);\n    let on = node.props.on ? (Array.isArray(node.props.on) ? node.props.on : [node.props.on]) : [];\n    let raiseError = (error) => raise(error, node, domParent, frame, scheduler);\n    let wrapped = wrapEvents(on, raiseError);\n    scheduler.enqueueTasks([() => _events.on(wrapped)]);\n    if (!_dom.isConnected) {\n        scheduler.enqueueTasks([() => _dom.dispatchEvent(createConnectEvent({ bubbles: false }))]);\n    }\n    extras._events = _events;\n    return Object.assign(node, extras);\n}\nfunction dispatchError(error) {\n    // TODO: dispatch on root target\n    // console.error(error)\n}\nfunction getCatchFallback(vnode, error) {\n    let content = typeof vnode._fallback === 'function' ? vnode._fallback(error) : vnode._fallback;\n    return toVNode(content);\n}\nfunction raise(error, descendant, domParent, frame, scheduler) {\n    let catchBoundary = findCatchBoundary(descendant);\n    if (catchBoundary) {\n        let content = getCatchFallback(catchBoundary, error);\n        let anchor = findFirstDomAnchor(catchBoundary) ||\n            findNextSiblingDomAnchor(catchBoundary, catchBoundary._parent) ||\n            undefined;\n        insert(content, domParent, frame, scheduler, catchBoundary, anchor);\n        for (let child of catchBoundary._added) {\n            remove(child, domParent, scheduler);\n        }\n        commitCatch(catchBoundary, { _tripped: true, _added: [content] });\n    }\n    else {\n        dispatchError(error);\n    }\n}\nfunction findCatchBoundary(vnode) {\n    let current = vnode;\n    while (current) {\n        if (isCommittedCatchNode(current))\n            return current;\n        current = current._parent;\n    }\n    return null;\n}\nfunction wrapEvents(on, raise) {\n    if (!Array.isArray(on))\n        on = [on];\n    return on.map((descriptor) => {\n        let handler = descriptor.handler;\n        Object.assign(descriptor, {\n            handler: (event, signal) => {\n                try {\n                    return handler(event, signal);\n                }\n                catch (error) {\n                    raise(error);\n                }\n            },\n        });\n        return descriptor;\n    });\n}\nfunction isFragmentNode(node) {\n    return node.type === Fragment;\n}\nfunction isCatchNode(node) {\n    return node.type === Catch;\n}\nfunction isTextNode(node) {\n    return node.type === TEXT_NODE;\n}\nfunction isCommittedTextNode(node) {\n    return isTextNode(node) && node._dom instanceof Text;\n}\nfunction isHostNode(node) {\n    return typeof node.type === 'string';\n}\nfunction isCommittedHostNode(node) {\n    return isHostNode(node) && node._dom instanceof Element;\n}\nfunction isRemixElement(node) {\n    return typeof node === 'object' && node !== null && '$rmx' in node;\n}\nfunction findFirstDomAnchor(node) {\n    if (!node)\n        return null;\n    if (isCommittedTextNode(node))\n        return node._dom;\n    if (isCommittedHostNode(node))\n        return node._dom;\n    if (isCommittedComponentNode(node))\n        return findFirstDomAnchor(node._content);\n    if (isFragmentNode(node)) {\n        for (let child of node._children) {\n            let dom = findFirstDomAnchor(child);\n            if (dom)\n                return dom;\n        }\n    }\n    if (isCommittedCatchNode(node)) {\n        for (let child of node._added) {\n            let dom = findFirstDomAnchor(child);\n            if (dom)\n                return dom;\n        }\n    }\n    return null;\n}\nfunction findNextSiblingDomAnchor(curr, vParent) {\n    if (!vParent || !Array.isArray(vParent._children))\n        return null;\n    let children = vParent._children;\n    let idx = children.indexOf(curr);\n    if (idx === -1)\n        return null;\n    for (let i = idx + 1; i < children.length; i++) {\n        let dom = findFirstDomAnchor(children[i]);\n        if (dom)\n            return dom;\n    }\n    return null;\n}\nfunction skipComments(cursor) {\n    while (cursor && cursor.nodeType === Node.COMMENT_NODE) {\n        cursor = cursor.nextSibling;\n    }\n    return cursor;\n}\n//# sourceMappingURL=vdom.js.map",
    "import { createElement, createFrameHandle } from \"./component.js\";\nimport { invariant } from \"./invariant.js\";\nimport { diffNodes } from \"./diff-dom.js\";\nimport { createRangeRoot, createScheduler } from \"./vdom.js\";\nconst TOP_FRAME = Symbol('TOP_FRAME');\nconst defaultInit = {\n    loadModule: async () => {\n        throw new Error('loadModule not implemented');\n    },\n    pendingHydrationRoots: new Map(),\n    src: '/',\n    scheduler: createScheduler(),\n    resolveFrame: async () => {\n        throw new Error('resolveFrame not implemented');\n    },\n};\nexport function createFrame(root, init) {\n    let config = { ...defaultInit, ...init };\n    let container = createContainer(root);\n    let scheduler = config.scheduler;\n    let frame = createFrameHandle({\n        src: config.src,\n        reload: async () => {\n            let content = await config.resolveFrame(config.src);\n            await render(content);\n        },\n        replace: async (content) => {\n            await render(content);\n        },\n    });\n    let context = {\n        frame,\n        loadModule: config.loadModule,\n        pendingRoots: config.pendingHydrationRoots,\n        scheduler: config.scheduler,\n        addFrame(start) {\n            let end = findEndComment(start);\n            let script = end.nextElementSibling;\n            invariant(script instanceof HTMLScriptElement, 'Invalid frame script');\n            let marker = parseFrameScript(script);\n            createFrame([start, end], { ...config, src: marker.src, marker });\n            return script;\n        },\n    };\n    async function render(content) {\n        let fragment = typeof content === 'string' ? createFragmentFromString(content) : content;\n        let nextContainer = createContainer(fragment);\n        await populatePendingRoots(nextContainer, context);\n        diffNodes(container.childNodes, Array.from(nextContainer.childNodes), context);\n        hydratedAndCreateSubFrames(container.childNodes, context);\n    }\n    async function hydrate() {\n        await populatePendingRoots(container, context);\n        hydratedAndCreateSubFrames(Array.from(container.childNodes), context);\n        if (config.marker?.status === 'pending') {\n            let earlyContent = getEarlyFrameContent(config.marker.id);\n            if (earlyContent) {\n                await render(earlyContent);\n            }\n            else {\n                setupTemplateObserver(config.marker.id, render);\n            }\n        }\n    }\n    let hydratePromise = hydrate();\n    return {\n        render,\n        ready: () => hydratePromise,\n        flush: () => scheduler.dequeue(),\n    };\n}\nfunction getEarlyFrameContent(id) {\n    let template = document.querySelector(`template#${id}`);\n    if (template instanceof HTMLTemplateElement) {\n        let fragment = template.content;\n        template.remove();\n        return fragment;\n    }\n    return null;\n}\nfunction setupTemplateObserver(id, cb) {\n    let observer = new MutationObserver(async (mutations) => {\n        for (let mutation of mutations) {\n            for (let node of mutation.addedNodes) {\n                if (node instanceof HTMLTemplateElement && node.id === id) {\n                    observer.disconnect();\n                    node.remove();\n                    cb(node.content);\n                }\n            }\n        }\n    });\n    observer.observe(document.body, { childList: true });\n}\nfunction parseFrameScript(script) {\n    let data = JSON.parse(script.textContent || '{}');\n    invariant(isFrameMarker(data));\n    return data;\n}\nfunction isFrameMarker(object) {\n    return (typeof object === 'object' &&\n        object !== null &&\n        'src' in object &&\n        'id' in object &&\n        'status' in object);\n}\nfunction findEndComment(comment) {\n    let node = comment.nextSibling;\n    while (node && node.nodeType !== 8) {\n        node = node.nextSibling;\n        if (node instanceof Comment && node.data.trim().startsWith('frame:end')) {\n            return node;\n        }\n    }\n    throw new Error('End comment not found');\n}\nfunction findCommentAbove(anchor, data) {\n    let node = anchor.previousSibling;\n    while (node && node.nodeType !== 8) {\n        node = node.previousSibling;\n        if (node instanceof Comment && node.data.trim() === data) {\n            return node;\n        }\n    }\n    invariant(false, 'Start comment not found');\n}\nfunction hydrate(vElement, start, end, context) {\n    context.pendingRoots.delete(start);\n    let root = createRangeRoot([start, end], {\n        scheduler: context.scheduler,\n        frame: context.frame,\n        // TODO: vParent: context.vParent,\n    });\n    Object.defineProperty(start, '$rmx', { value: root, enumerable: false });\n    root.render(vElement);\n}\nexport function isVirtualStartMarker(node) {\n    return '$rmx' in node;\n}\nfunction hydratedAndCreateSubFrames(nodes, context) {\n    for (let i = 0; i < nodes.length; i++) {\n        let node = nodes[i];\n        if (node instanceof Comment && context.pendingRoots.has(node)) {\n            let info = context.pendingRoots.get(node);\n            invariant(info, 'Expected hydration element');\n            let [end, element] = info;\n            hydrate(element, node, end, context);\n            // advance cursor to node after end marker\n            i = nodes.indexOf(end);\n        }\n        if (isFrameStart(node)) {\n            let frameScript = context.addFrame(node);\n            i = nodes.indexOf(frameScript); // advance past frame script\n            frameScript.remove();\n        }\n        else if (node.childNodes.length > 0) {\n            hydratedAndCreateSubFrames(Array.from(node.childNodes), context);\n        }\n    }\n}\nfunction createFragmentFromString(content) {\n    let template = document.createElement('template');\n    template.innerHTML = content.trim();\n    return template.content;\n}\nfunction isFrameStart(node) {\n    return node instanceof Comment && node.data.trim().startsWith('frame:start:');\n}\nconst hydrationScriptSelector = 'script[type=\"application/json\"][rmx-hydrated]';\n// pending roots map is shared by child frames so we can populate from the\n// parent and load all found modules in parallel and keep diffing synchronous\nasync function populatePendingRoots(container, context) {\n    let scripts = queryHydrationScripts(container);\n    await Promise.all(scripts.map(async (script) => {\n        let data = JSON.parse(script.textContent || '{}');\n        invariant(isHydrationScript(data), 'Invalid hydration script');\n        let mod = await context.loadModule(data.moduleUrl, data.exportName);\n        let vElement = createElement(mod, data.props);\n        let [start, end] = getVirtualRootMarkersFromScript(script);\n        context.pendingRoots.set(start, [end, vElement]);\n        script.remove(); // remove before diffing\n    }));\n}\nfunction getVirtualRootMarkersFromScript(script) {\n    let end = script.previousSibling;\n    invariant(end instanceof Comment, 'Expected comment');\n    let start = findCommentAbove(end, 'rmx:h');\n    return [start, end];\n}\nfunction queryHydrationScripts(container) {\n    return Array.from(container.root.querySelectorAll(hydrationScriptSelector));\n}\nfunction isHydrationScript(object) {\n    return (typeof object === 'object' &&\n        object !== null &&\n        'moduleUrl' in object &&\n        'exportName' in object &&\n        'props' in object);\n}\nfunction createContainer(container) {\n    return Array.isArray(container)\n        ? createCommentContainer(container)\n        : createElementContainer(container);\n}\nfunction createElementContainer(container) {\n    return {\n        root: container,\n        appendChild: (node) => container.appendChild(node),\n        get childNodes() {\n            return Array.from(container.childNodes);\n        },\n        querySelectorAll: (selector) => Array.from(container.querySelectorAll(selector)),\n        querySelector: (selector) => container.querySelector(selector),\n        insertBefore: (node, before) => container.insertBefore(node, before),\n    };\n}\nfunction createCommentContainer(container) {\n    let root = container[1].parentNode;\n    invariant(root, 'Invalid comment container');\n    let appendChild = (node) => {\n        root.insertBefore(node, container[1]);\n    };\n    let getChildNodesBetween = () => {\n        let nodes = [];\n        let node = container[0].nextSibling;\n        while (node && node !== container[1]) {\n            nodes.push(node);\n            node = node.nextSibling;\n        }\n        return nodes;\n    };\n    let querySelectorAll = (selector) => {\n        let range = document.createRange();\n        range.setStartAfter(container[0]);\n        range.setEndBefore(container[1]);\n        let all = root.querySelectorAll(selector);\n        let results = [];\n        for (let i = 0; i < all.length; i++) {\n            let el = all[i];\n            if (range.intersectsNode(el))\n                results.push(el);\n        }\n        return results;\n    };\n    let querySelector = (selector) => {\n        let range = document.createRange();\n        range.setStartAfter(container[0]);\n        range.setEndBefore(container[1]);\n        let all = root.querySelectorAll(selector);\n        for (let i = 0; i < all.length; i++) {\n            let el = all[i];\n            if (range.intersectsNode(el))\n                return el;\n        }\n        return null;\n    };\n    let insertBefore = (node, before) => {\n        root.insertBefore(node, before);\n    };\n    return {\n        get childNodes() {\n            return getChildNodesBetween();\n        },\n        appendChild,\n        querySelectorAll,\n        querySelector,\n        insertBefore,\n        root,\n    };\n}\n//# sourceMappingURL=frame.js.map",
    "import { createFrame } from '@remix-run/dom'\n\ncreateFrame(document, {\n  async loadModule(moduleUrl, name) {\n    let mod = await import(moduleUrl)\n    if (!mod) {\n      throw new Error(`Unknown module: ${moduleUrl}#${name}`)\n    }\n\n    let Component = mod[name]\n    if (!Component) {\n      throw new Error(`Unknown component: ${moduleUrl}#${name}`)\n    }\n\n    return Component\n  },\n\n  async resolveFrame(frameUrl) {\n    let res = await fetch(frameUrl)\n    if (res.ok) {\n      return res.text()\n    }\n\n    throw new Error(`Failed to fetch ${frameUrl}`)\n  },\n})\n"
  ],
  "mappings": "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",
  "debugId": "003FC310F6779A0964756E2164756E21",
  "names": []
}