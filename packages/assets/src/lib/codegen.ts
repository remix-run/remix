import * as path from 'node:path'
import * as fsp from 'node:fs/promises'
import * as fs from 'node:fs'
import { compileFileRules, normalizeSourcePath } from './files.ts'
import type { FilesConfig, CompiledFileRule } from './files.ts'

export interface CodegenOptions {
  /** Script entry paths relative to root (e.g. ['app/entry.tsx']) */
  scripts?: string[]
  /** Project root. Default: process.cwd(). */
  root?: string
  /** File transformation rules for non-JS assets. */
  files?: FilesConfig
  /**
   * Directory for generated .dev.ts and .build.ts asset files.
   * Default: '.assets'
   */
  codegenDir?: string
}

export interface CodegenWatcher {
  close(): void
}

export const GENERATED_MARKER = '// @generated by remix/assets â€” do not edit manually'

export function generateDevScriptContent(sourcePath: string): string {
  let href = `/${sourcePath}`
  return (
    [
      GENERATED_MARKER,
      `// source: ${sourcePath}`,
      `export const href = '${href}'`,
      `export const preloads = ['${href}']`,
    ].join('\n') + '\n'
  )
}

export function generateDevFileContent(sourcePath: string, rule: CompiledFileRule): string {
  let baseUrl = `/__@files/${sourcePath}`
  let lines = [GENERATED_MARKER, `// source: ${sourcePath}`]

  if (rule.variants) {
    let variantNames = Object.keys(rule.variants)
    if (rule.defaultVariant) {
      lines.push(`export const href = '${baseUrl}?@${rule.defaultVariant}'`)
    }
    lines.push(`export const variants = {`)
    for (let variant of variantNames) {
      lines.push(`  ${variant}: { href: '${baseUrl}?@${variant}' },`)
    }
    lines.push(`}`)
  } else {
    lines.push(`export const href = '${baseUrl}'`)
  }

  return lines.join('\n') + '\n'
}

export function toCodegenFilePath(
  sourcePath: string,
  codegenAbsDir: string,
  ext: 'dev' | 'build',
): string {
  return path.join(codegenAbsDir, ...sourcePath.split('/')) + `.${ext}.ts`
}

export async function writeIfChanged(filePath: string, content: string): Promise<void> {
  await fsp.mkdir(path.dirname(filePath), { recursive: true })
  let existing: string | null = null
  try {
    existing = await fsp.readFile(filePath, 'utf-8')
  } catch {
    // file doesn't exist, will be created
  }
  if (existing !== content) {
    await fsp.writeFile(filePath, content, 'utf-8')
  }
}

async function tryDeleteGenerated(filePath: string): Promise<void> {
  let content: string
  try {
    content = await fsp.readFile(filePath, 'utf-8')
  } catch {
    return
  }
  if (content.startsWith(GENERATED_MARKER)) {
    await fsp.unlink(filePath)
  }
}

async function collectDevFiles(dir: string): Promise<string[]> {
  let results: string[] = []

  async function walk(absDir: string): Promise<void> {
    let entries
    try {
      entries = await fsp.readdir(absDir, { withFileTypes: true })
    } catch {
      return
    }
    await Promise.all(
      entries.map(async (entry) => {
        let fullPath = path.join(absDir, entry.name)
        if (entry.isDirectory()) {
          await walk(fullPath)
        } else if (entry.isFile() && entry.name.endsWith('.dev.ts')) {
          results.push(fullPath)
        }
      }),
    )
  }

  await walk(dir)
  return results
}

async function walkSourceFiles(root: string, skipDir: string): Promise<string[]> {
  let results: string[] = []

  async function walk(dir: string): Promise<void> {
    let entries
    try {
      entries = await fsp.readdir(dir, { withFileTypes: true })
    } catch {
      return
    }
    await Promise.all(
      entries.map(async (entry) => {
        let fullPath = path.join(dir, entry.name)
        if (entry.isDirectory()) {
          if (entry.name === 'node_modules' || entry.name === '.git' || fullPath === skipDir) {
            return
          }
          await walk(fullPath)
        } else if (entry.isFile()) {
          results.push(normalizeSourcePath(path.relative(root, fullPath)))
        }
      }),
    )
  }

  await walk(root)
  return results
}

/** Result returned by codegenCheck(). */
export interface CodegenCheckResult {
  /** True when there are no missing, stale, or outdated files. */
  ok: boolean
  /** Paths (relative to root) of .dev.ts files that should exist but are absent from disk. */
  missing: string[]
  /** Paths (relative to root) of .dev.ts files on disk that have no matching source file or rule. */
  stale: string[]
  /** Paths (relative to root) of .dev.ts files whose content differs from what would be generated. */
  outdated: string[]
}

/**
 * Validates that the .dev.ts files on disk exactly match what codegen() would produce.
 * Reports missing files, stale files with no corresponding source, and files with
 * outdated content. Does not write anything to disk.
 *
 * Suitable for CI checks to ensure committed .dev.ts files are up to date.
 *
 * @param options Codegen configuration (root, scripts, files, codegenDir)
 * @returns A result object with ok flag and lists of missing, stale, and outdated files
 */
export async function codegenCheck(options: CodegenOptions): Promise<CodegenCheckResult> {
  let root = path.resolve(process.cwd(), options.root ?? '.')
  let codegenAbsDir = path.resolve(root, options.codegenDir ?? '.assets')
  let scripts = (options.scripts ?? []).map(normalizeSourcePath)
  let compiledRules = compileFileRules(options.files)

  let expected = new Map<string, string>()

  for (let sourcePath of scripts) {
    let absoluteSrc = path.join(root, ...sourcePath.split('/'))
    try {
      await fsp.stat(absoluteSrc)
    } catch {
      continue
    }
    let devFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'dev')
    expected.set(devFilePath, generateDevScriptContent(sourcePath))
  }

  if (compiledRules.length > 0) {
    let allFiles = await walkSourceFiles(root, codegenAbsDir)
    await Promise.all(
      allFiles.map(async (sourcePath) => {
        let rule = compiledRules.find((r) => r.matcher(sourcePath))
        if (!rule) return
        let devFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'dev')
        expected.set(devFilePath, generateDevFileContent(sourcePath, rule))
      }),
    )
  }

  let existingDevFiles = await collectDevFiles(codegenAbsDir)
  let existingSet = new Set(existingDevFiles)

  let missing: string[] = []
  let outdated: string[] = []
  let stale: string[] = []

  for (let [absFilePath, expectedContent] of expected) {
    if (!existingSet.has(absFilePath)) {
      missing.push(path.relative(root, absFilePath))
    } else {
      let actualContent = await fsp.readFile(absFilePath, 'utf-8')
      if (actualContent !== expectedContent) {
        outdated.push(path.relative(root, absFilePath))
      }
    }
  }

  for (let absFilePath of existingDevFiles) {
    if (!expected.has(absFilePath)) {
      stale.push(path.relative(root, absFilePath))
    }
  }

  return {
    ok: missing.length === 0 && outdated.length === 0 && stale.length === 0,
    missing,
    stale,
    outdated,
  }
}

/**
 * One-shot generation of .dev.ts files for all source assets matching the
 * configured scripts and files patterns. Deletes stale .dev.ts files where
 * the source file no longer exists.
 *
 * Suitable for CI and pre-typecheck scripts.
 *
 * @param options Codegen configuration (root, scripts, files, codegenDir)
 */
export async function codegen(options: CodegenOptions): Promise<void> {
  let root = path.resolve(process.cwd(), options.root ?? '.')
  let codegenAbsDir = path.resolve(root, options.codegenDir ?? '.assets')
  let scripts = (options.scripts ?? []).map(normalizeSourcePath)
  let compiledRules = compileFileRules(options.files)

  let expectedDevFiles = new Set<string>()

  for (let sourcePath of scripts) {
    let absoluteSrc = path.join(root, ...sourcePath.split('/'))
    try {
      await fsp.stat(absoluteSrc)
    } catch {
      continue
    }
    let devFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'dev')
    expectedDevFiles.add(devFilePath)
    await writeIfChanged(devFilePath, generateDevScriptContent(sourcePath))
  }

  if (compiledRules.length > 0) {
    let allFiles = await walkSourceFiles(root, codegenAbsDir)
    await Promise.all(
      allFiles.map(async (sourcePath) => {
        let rule = compiledRules.find((r) => r.matcher(sourcePath))
        if (!rule) return
        let devFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'dev')
        expectedDevFiles.add(devFilePath)
        await writeIfChanged(devFilePath, generateDevFileContent(sourcePath, rule))
      }),
    )
  }

  let existingDevFiles = await collectDevFiles(codegenAbsDir)
  await Promise.all(
    existingDevFiles.map(async (filePath) => {
      if (!expectedDevFiles.has(filePath)) {
        await tryDeleteGenerated(filePath)
      }
    }),
  )
}

/**
 * Long-running watcher that keeps .dev.ts files up to date.
 *
 * Runs a full codegen() pass synchronously on startup before resolving, so
 * Node.js can import all #assets/... paths immediately when the server starts.
 * Then watches for file additions and deletions matching the configured patterns.
 *
 * @param options Codegen configuration (root, scripts, files, codegenDir)
 * @returns A watcher object with a close() method to stop watching
 */
export async function codegenWatch(options: CodegenOptions): Promise<CodegenWatcher> {
  let root = path.resolve(process.cwd(), options.root ?? '.')
  let codegenRelDir = options.codegenDir ?? '.assets'
  let codegenAbsDir = path.resolve(root, codegenRelDir)
  let codegenDirPrefix = normalizeSourcePath(path.relative(root, codegenAbsDir))
  let scripts = (options.scripts ?? []).map(normalizeSourcePath)
  let compiledRules = compileFileRules(options.files)

  await codegen(options)

  let watcher = fs.watch(root, { recursive: true }, (eventType, filename) => {
    if (!filename) return
    let sourcePath = normalizeSourcePath(filename)

    if (
      sourcePath === codegenDirPrefix ||
      sourcePath.startsWith(codegenDirPrefix + '/') ||
      sourcePath.startsWith('node_modules/') ||
      sourcePath.startsWith('.git/')
    ) {
      return
    }

    let isScript = scripts.includes(sourcePath)
    let matchingRule = isScript ? null : compiledRules.find((r) => r.matcher(sourcePath))
    if (!isScript && !matchingRule) return

    let devFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'dev')
    let absoluteSrc = path.join(root, ...sourcePath.split('/'))

    fsp.stat(absoluteSrc).then(
      () => {
        let content = isScript
          ? generateDevScriptContent(sourcePath)
          : generateDevFileContent(sourcePath, matchingRule!)
        return writeIfChanged(devFilePath, content)
      },
      () => tryDeleteGenerated(devFilePath),
    )
  })

  return { close: () => watcher.close() }
}
