import * as path from 'node:path'
import * as fsp from 'node:fs/promises'
import * as fs from 'node:fs'
import MagicString from 'magic-string'
import { compileFileRules, normalizeSourcePath } from './files.ts'
import type { FilesConfig, CompiledFileRule, AssetsSource } from './files.ts'
import type { AssetsManifest } from './manifest-types.ts'

export interface CodegenOptions {
  /** Source definition (scripts + file rules). */
  source?: AssetsSource
  /** Project root. Default: process.cwd(). */
  root?: string
  /**
   * Directory for generated .placeholder.ts and .build.ts asset files.
   * Default: '.assets'
   */
  codegenDir?: string
}

export interface CodegenWatcher {
  close(): void
}

export const GENERATED_MARKER = '// @generated by remix/assets — do not edit manually'

export function generatePlaceholderScriptContent(sourcePath: string): string {
  let href = `/__@assets/${sourcePath}`
  return (
    [
      GENERATED_MARKER,
      `// source: ${sourcePath}`,
      `export const href = '${href}'`,
      `export const preloads = ['${href}#preloads']`,
    ].join('\n') + '\n'
  )
}

export function generatePlaceholderFileContent(sourcePath: string, rule: CompiledFileRule): string {
  let baseUrl = `/__@assets/${sourcePath}`
  let lines = [GENERATED_MARKER, `// source: ${sourcePath}`]

  if (rule.variants) {
    let variantNames = Object.keys(rule.variants)
    if (rule.defaultVariant) {
      lines.push(`export const href = '${baseUrl}?@${rule.defaultVariant}'`)
    }
    lines.push(`export const variants = {`)
    for (let variant of variantNames) {
      lines.push(`  ${variant}: { href: '${baseUrl}?@${variant}' },`)
    }
    lines.push(`}`)
  } else {
    lines.push(`export const href = '${baseUrl}'`)
  }

  return lines.join('\n') + '\n'
}

export function toCodegenFilePath(
  sourcePath: string,
  codegenAbsDir: string,
  ext: 'placeholder' | 'build',
): string {
  return path.join(codegenAbsDir, ...sourcePath.split('/')) + `.${ext}.ts`
}

export async function writeIfChanged(filePath: string, content: string): Promise<void> {
  await fsp.mkdir(path.dirname(filePath), { recursive: true })
  let existing: string | null = null
  try {
    existing = await fsp.readFile(filePath, 'utf-8')
  } catch {
    // file doesn't exist, will be created
  }
  if (existing !== content) {
    await fsp.writeFile(filePath, content, 'utf-8')
  }
}

async function tryDeleteGenerated(filePath: string): Promise<void> {
  let content: string
  try {
    content = await fsp.readFile(filePath, 'utf-8')
  } catch {
    return
  }
  if (content.startsWith(GENERATED_MARKER)) {
    await fsp.unlink(filePath)
  }
}

async function collectCodegenFiles(
  dir: string,
): Promise<{ placeholderFiles: string[]; unknownFiles: string[] }> {
  let placeholderFiles: string[] = []
  let unknownFiles: string[] = []

  async function walk(absDir: string): Promise<void> {
    let entries
    try {
      entries = await fsp.readdir(absDir, { withFileTypes: true })
    } catch {
      return
    }
    await Promise.all(
      entries.map(async (entry) => {
        let fullPath = path.join(absDir, entry.name)
        if (entry.isDirectory()) {
          await walk(fullPath)
        } else if (entry.isFile()) {
          if (entry.name.endsWith('.placeholder.ts')) {
            placeholderFiles.push(fullPath)
          } else if (!entry.name.endsWith('.build.ts')) {
            unknownFiles.push(fullPath)
          }
        }
      }),
    )
  }

  await walk(dir)
  return { placeholderFiles, unknownFiles }
}

async function walkSourceFiles(root: string, skipDir: string): Promise<string[]> {
  let results: string[] = []

  async function walk(dir: string): Promise<void> {
    let entries
    try {
      entries = await fsp.readdir(dir, { withFileTypes: true })
    } catch {
      return
    }
    await Promise.all(
      entries.map(async (entry) => {
        let fullPath = path.join(dir, entry.name)
        if (entry.isDirectory()) {
          if (entry.name === 'node_modules' || entry.name === '.git' || fullPath === skipDir) {
            return
          }
          await walk(fullPath)
        } else if (entry.isFile()) {
          results.push(normalizeSourcePath(path.relative(root, fullPath)))
        }
      }),
    )
  }

  await walk(root)
  return results
}

/** Options for checkCodegenPlaceholders(). */
export interface CodegenCheckOptions extends CodegenOptions {
  /**
   * When true, files in the codegenDir that are neither .placeholder.ts nor .build.ts are
   * reported as unknown but do not affect ok. Default: false.
   */
  allowUnknownFiles?: boolean
}

/** Result returned by checkCodegenPlaceholders(). */
export interface CodegenCheckResult {
  /** True when there are no missing, stale, outdated, or (when allowUnknownFiles is false) unknown files. */
  ok: boolean
  /** Paths (relative to root) of .placeholder.ts files that should exist but are absent from disk. */
  missing: string[]
  /** Paths (relative to root) of .placeholder.ts files on disk that have no matching source file or rule. */
  stale: string[]
  /** Paths (relative to root) of .placeholder.ts files whose content differs from what would be generated. */
  outdated: string[]
  /**
   * Paths (relative to root) of files in the codegenDir that are neither .placeholder.ts nor .build.ts.
   * Only affects ok when allowUnknownFiles is false (the default).
   */
  unknown: string[]
}

/**
 * Validates that the .placeholder.ts files on disk exactly match what codegenPlaceholders() would produce.
 * Reports missing files, stale files with no corresponding source, files with outdated
 * content, and (unless allowUnknownFiles is true) any unexpected files in the codegenDir.
 * Does not write anything to disk.
 *
 * Suitable for CI checks to ensure committed .placeholder.ts files are up to date.
 *
 * @param options Codegen configuration (root, scripts, files, codegenDir, allowUnknownFiles)
 * @returns A result object with ok flag and lists of missing, stale, outdated, and unknown files
 */
export async function checkCodegenPlaceholders(
  options: CodegenCheckOptions,
): Promise<CodegenCheckResult> {
  let root = path.resolve(process.cwd(), options.root ?? '.')
  let codegenAbsDir = path.resolve(root, options.codegenDir ?? '.assets')
  let scripts = (options.source?.scripts ?? []).map(normalizeSourcePath)
  let compiledRules = compileFileRules(options.source?.files)

  let expected = new Map<string, string>()

  for (let sourcePath of scripts) {
    let absoluteSrc = path.join(root, ...sourcePath.split('/'))
    try {
      await fsp.stat(absoluteSrc)
    } catch {
      continue
    }
    let placeholderFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'placeholder')
    expected.set(placeholderFilePath, generatePlaceholderScriptContent(sourcePath))
  }

  if (compiledRules.length > 0) {
    let allFiles = await walkSourceFiles(root, codegenAbsDir)
    await Promise.all(
      allFiles.map(async (sourcePath) => {
        let rule = compiledRules.find((r) => r.matcher(sourcePath))
        if (!rule) return
        let placeholderFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'placeholder')
        expected.set(placeholderFilePath, generatePlaceholderFileContent(sourcePath, rule))
      }),
    )
  }

  let { placeholderFiles, unknownFiles } = await collectCodegenFiles(codegenAbsDir)
  let existingSet = new Set(placeholderFiles)

  let missing: string[] = []
  let outdated: string[] = []
  let stale: string[] = []

  for (let [absFilePath, expectedContent] of expected) {
    if (!existingSet.has(absFilePath)) {
      missing.push(path.relative(root, absFilePath))
    } else {
      let actualContent = await fsp.readFile(absFilePath, 'utf-8')
      if (actualContent !== expectedContent) {
        outdated.push(path.relative(root, absFilePath))
      }
    }
  }

  for (let absFilePath of placeholderFiles) {
    if (!expected.has(absFilePath)) {
      stale.push(path.relative(root, absFilePath))
    }
  }

  let unknown = unknownFiles.map((f) => path.relative(root, f))

  return {
    ok:
      missing.length === 0 &&
      outdated.length === 0 &&
      stale.length === 0 &&
      (options.allowUnknownFiles === true || unknown.length === 0),
    missing,
    stale,
    outdated,
    unknown,
  }
}

/**
 * One-shot generation of .placeholder.ts files for all source assets matching the
 * configured scripts and files patterns. Deletes stale .placeholder.ts files where
 * the source file no longer exists.
 *
 * Suitable for CI and pre-typecheck scripts.
 *
 * @param options Codegen configuration (root, scripts, files, codegenDir)
 */
export async function codegenPlaceholders(options: CodegenOptions): Promise<void> {
  let root = path.resolve(process.cwd(), options.root ?? '.')
  let codegenAbsDir = path.resolve(root, options.codegenDir ?? '.assets')
  let scripts = (options.source?.scripts ?? []).map(normalizeSourcePath)
  let compiledRules = compileFileRules(options.source?.files)

  let expectedPlaceholderFiles = new Set<string>()

  for (let sourcePath of scripts) {
    let absoluteSrc = path.join(root, ...sourcePath.split('/'))
    try {
      await fsp.stat(absoluteSrc)
    } catch {
      continue
    }
    let placeholderFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'placeholder')
    expectedPlaceholderFiles.add(placeholderFilePath)
    await writeIfChanged(placeholderFilePath, generatePlaceholderScriptContent(sourcePath))
  }

  if (compiledRules.length > 0) {
    let allFiles = await walkSourceFiles(root, codegenAbsDir)
    await Promise.all(
      allFiles.map(async (sourcePath) => {
        let rule = compiledRules.find((r) => r.matcher(sourcePath))
        if (!rule) return
        let placeholderFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'placeholder')
        expectedPlaceholderFiles.add(placeholderFilePath)
        await writeIfChanged(placeholderFilePath, generatePlaceholderFileContent(sourcePath, rule))
      }),
    )
  }

  let { placeholderFiles } = await collectCodegenFiles(codegenAbsDir)
  await Promise.all(
    placeholderFiles.map(async (filePath: string) => {
      if (!expectedPlaceholderFiles.has(filePath)) {
        await tryDeleteGenerated(filePath)
      }
    }),
  )
}

/**
 * Long-running watcher that keeps .placeholder.ts files up to date.
 *
 * Runs a full codegenPlaceholders() pass synchronously on startup before resolving, so
 * Node.js can import all #assets/... paths immediately when the server starts.
 * Then watches for file additions and deletions matching the configured patterns.
 *
 * @param options Codegen configuration (root, scripts, files, codegenDir)
 * @returns A watcher object with a close() method to stop watching
 */
export async function watchCodegenPlaceholders(options: CodegenOptions): Promise<CodegenWatcher> {
  let root = path.resolve(process.cwd(), options.root ?? '.')
  let codegenRelDir = options.codegenDir ?? '.assets'
  let codegenAbsDir = path.resolve(root, codegenRelDir)
  let codegenDirPrefix = normalizeSourcePath(path.relative(root, codegenAbsDir))
  let scripts = (options.source?.scripts ?? []).map(normalizeSourcePath)
  let compiledRules = compileFileRules(options.source?.files)

  await codegenPlaceholders(options)

  let watcher = fs.watch(root, { recursive: true }, (eventType, filename) => {
    if (!filename) return
    let sourcePath = normalizeSourcePath(filename)

    if (
      sourcePath === codegenDirPrefix ||
      sourcePath.startsWith(codegenDirPrefix + '/') ||
      sourcePath.startsWith('node_modules/') ||
      sourcePath.startsWith('.git/')
    ) {
      return
    }

    let isScript = scripts.includes(sourcePath)
    let matchingRule = isScript ? null : compiledRules.find((r) => r.matcher(sourcePath))
    if (!isScript && !matchingRule) return

    let placeholderFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'placeholder')
    let absoluteSrc = path.join(root, ...sourcePath.split('/'))

    fsp.stat(absoluteSrc).then(
      () => {
        let content = isScript
          ? generatePlaceholderScriptContent(sourcePath)
          : generatePlaceholderFileContent(sourcePath, matchingRule!)
        return writeIfChanged(placeholderFilePath, content)
      },
      () => tryDeleteGenerated(placeholderFilePath),
    )
  })

  return { close: () => watcher.close() }
}

function toAssetUrl(outputPath: string, baseUrl: string): string {
  let segment = outputPath.replace(/^\.?\//, '')
  if (baseUrl !== '') {
    let base = baseUrl.replace(/\/+$/, '')
    return base ? `${base}/${segment}` : `/${segment}`
  }
  return `/${segment}`
}

function formatPreloads(urls: string[]): string {
  if (urls.length === 0) return '[]'
  if (urls.length === 1) return `['${urls[0]}']`
  return `[\n${urls.map((u) => `  '${u}'`).join(',\n')},\n]`
}

function generateBuildScriptContent(
  sourcePath: string,
  outputPath: string,
  preloadUrls: string[],
  baseUrl: string,
): string {
  let href = toAssetUrl(outputPath, baseUrl)
  return (
    [
      GENERATED_MARKER,
      `// source: ${sourcePath}`,
      `export const href = '${href}'`,
      `export const preloads = ${formatPreloads(preloadUrls)}`,
    ].join('\n') + '\n'
  )
}

function generateBuildFileContent(
  sourcePath: string,
  output: AssetsManifest['files']['outputs'][string],
  baseUrl: string,
): string {
  let lines = [GENERATED_MARKER, `// source: ${sourcePath}`]

  if ('variants' in output) {
    let variantEntries = Object.entries(output.variants)
    if (output.defaultVariant) {
      let defaultPath = output.variants[output.defaultVariant].path
      lines.push(`export const href = '${toAssetUrl(defaultPath, baseUrl)}'`)
    }
    lines.push(`export const variants = {`)
    for (let [variant, variantOutput] of variantEntries) {
      lines.push(`  ${variant}: { href: '${toAssetUrl(variantOutput.path, baseUrl)}' },`)
    }
    lines.push(`}`)
  } else {
    lines.push(`export const href = '${toAssetUrl(output.path, baseUrl)}'`)
  }

  return lines.join('\n') + '\n'
}

function collectPreloadsFromManifest(
  entryPath: string,
  manifest: AssetsManifest,
  baseUrl: string,
): string[] {
  let visited = new Set<string>()
  let urls: string[] = []

  function visit(outputPath: string) {
    if (visited.has(outputPath)) return
    visited.add(outputPath)
    urls.push(toAssetUrl(outputPath, baseUrl))
    let entry = manifest.scripts.outputs[outputPath]
    if (!entry) return
    for (let imp of entry.imports ?? []) {
      visit(imp.path)
    }
  }

  // Find the output path for this entry point
  for (let [outputPath, entry] of Object.entries(manifest.scripts.outputs)) {
    if (entry.entryPoint === entryPath) {
      visit(outputPath)
      break
    }
  }

  return urls
}

export interface CodegenBuildOptions {
  /** The assets manifest containing script and file outputs. */
  manifest: AssetsManifest
  /** URL prefix where built assets are served (e.g. '/assets'). */
  baseUrl: string
  /** Project root. Default: process.cwd(). */
  root?: string
  /**
   * Directory for generated .build.ts asset files.
   * Default: '.assets'
   */
  codegenDir?: string
}

/**
 * Generates .build.ts files from a manifest for production server runtime.
 * Called after the client build to make #assets/ imports resolve to real hashed URLs
 * at Node.js runtime (via the default package.json import condition).
 *
 * @param options Options including the manifest, baseUrl, root, and codegenDir
 */
export async function codegenBuild(options: CodegenBuildOptions): Promise<void> {
  let root = path.resolve(process.cwd(), options.root ?? '.')
  let codegenAbsDir = path.resolve(root, options.codegenDir ?? '.assets')
  let { manifest, baseUrl } = options

  // Generate .build.ts for script entries
  await Promise.all(
    Object.entries(manifest.scripts.outputs)
      .filter(([, entry]) => entry.entryPoint)
      .map(async ([outputPath, entry]) => {
        let sourcePath = entry.entryPoint!
        let preloadUrls = collectPreloadsFromManifest(sourcePath, manifest, baseUrl)
        let buildFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'build')
        await writeIfChanged(
          buildFilePath,
          generateBuildScriptContent(sourcePath, outputPath, preloadUrls, baseUrl),
        )
      }),
  )

  // Generate .build.ts for file outputs
  await Promise.all(
    Object.entries(manifest.files.outputs).map(async ([sourcePath, output]) => {
      let buildFilePath = toCodegenFilePath(sourcePath, codegenAbsDir, 'build')
      await writeIfChanged(buildFilePath, generateBuildFileContent(sourcePath, output, baseUrl))
    }),
  )
}

// --- substituteAssetPlaceholders ---

async function computeSubstituteHash(content: string): Promise<string> {
  let encoded = new TextEncoder().encode(content)
  let buffer = await crypto.subtle.digest('SHA-256', encoded)
  let hex = Array.from(new Uint8Array(buffer))
    .map((b) => b.toString(16).padStart(2, '0'))
    .join('')
  // 8-char base36 lowercase (a-z0-9) — same character set as most bundler hashes
  let n = BigInt('0x' + hex.slice(0, 12))
  return n.toString(36).padStart(10, '0').slice(-8)
}

function toPosixLocalPath(p: string): string {
  return p.replace(/\\/g, '/')
}

function toLocalRelativeSpecifier(fromLocalPath: string, toLocalPath: string): string {
  let fromDir = fromLocalPath.includes('/')
    ? fromLocalPath.slice(0, fromLocalPath.lastIndexOf('/'))
    : '.'
  let rel = path.posix.relative(fromDir, toLocalPath)
  return rel.startsWith('.') ? rel : './' + rel
}

function buildTopologicalOrder(manifest: AssetsManifest): string[] {
  let outputs = manifest.scripts.outputs
  let visited = new Set<string>()
  let order: string[] = []

  function visit(localPath: string) {
    if (visited.has(localPath)) return
    visited.add(localPath)
    for (let imp of outputs[localPath]?.imports ?? []) {
      visit(imp.path)
    }
    order.push(localPath)
  }

  for (let localPath of Object.keys(outputs)) visit(localPath)
  return order // dependencies (chunks) first, entry points last
}

export interface SubstituteAssetPlaceholdersOptions {
  /**
   * Assets manifest describing script and file output paths.
   * Mutated in-place to reflect any renamed output files.
   */
  manifest: AssetsManifest
  /** URL prefix where built assets are served (e.g. '/assets'). */
  baseUrl: string
  /** Directory containing the bundler output files. */
  outDir: string
  /**
   * Derive a new output path from the updated content hash.
   * Receives the absolute path of the file and an 8-char lowercase base36 hash of its new content.
   * Return the old path unchanged for files that should not be renamed.
   *
   * Default: replaces the trailing -HASH segment before the file extension.
   *
   * Example for esbuild [name]-[hash] pattern:
   *   (oldPath, newHash) => oldPath.replace(/-[A-Za-z0-9]+(\.[^.]+)$/, `-${newHash}$1`)
   */
  renameFile?: (oldPath: string, newHash: string) => string
}

/**
 * Post-processing pass for external bundler workflows (esbuild, Rollup, etc.).
 *
 * Replaces `/__@assets/` placeholder strings in bundled output with real hashed URLs,
 * recomputes content hashes for modified files, renames them, cascades import-path updates
 * topologically, and mutates the manifest in-place to reflect renamed files.
 *
 * Call this between the bundler build and codegenBuild:
 *
 * ```ts
 * let result = await esbuild.build({ ..., conditions: ['placeholder'], write: true, metafile: true })
 * let manifest = buildManifestFromMetafile(result.metafile)
 * await substituteAssetPlaceholders({ manifest, baseUrl: '/assets', outDir: './build/assets' })
 * await codegenBuild({ manifest, baseUrl: '/assets' })
 * ```
 *
 * @param options Options including manifest, baseUrl, outDir, and optional renameFile
 */
export async function substituteAssetPlaceholders(
  options: SubstituteAssetPlaceholdersOptions,
): Promise<void> {
  let { manifest, baseUrl } = options
  let outDir = path.resolve(process.cwd(), options.outDir)
  let renameFile =
    options.renameFile ??
    ((oldPath: string, newHash: string) =>
      oldPath.replace(/-[A-Za-z0-9]+(\.[^./]+)$/, `-${newHash}$1`))

  // Build source path → real serving URL from manifest.
  let sourcePathToRealUrl = new Map<string, string>()
  for (let [outputPath, entry] of Object.entries(manifest.scripts.outputs)) {
    if (entry.entryPoint) {
      sourcePathToRealUrl.set(entry.entryPoint, toAssetUrl(outputPath, baseUrl))
    }
  }
  for (let [sourcePath, output] of Object.entries(manifest.files.outputs)) {
    if ('path' in output) {
      sourcePathToRealUrl.set(sourcePath, toAssetUrl(output.path, baseUrl))
    } else if ('variants' in output) {
      for (let [variant, variantOutput] of Object.entries(output.variants)) {
        sourcePathToRealUrl.set(
          `${sourcePath}?@${variant}`,
          toAssetUrl(variantOutput.path, baseUrl),
        )
      }
    }
  }

  // Process files in topological order (dependencies first = chunks before entries).
  // When we process an entry, we already know if any imported chunk was renamed.
  let orderedLocalPaths = buildTopologicalOrder(manifest)

  // Track renames for cascade: old local path → new local path.
  let renames = new Map<string, string>()

  for (let localPath of orderedLocalPaths) {
    // Skip source map files — they are renamed alongside their JS files below.
    if (localPath.endsWith('.map')) continue

    let absPath = path.join(outDir, ...localPath.split('/'))
    let rawContent: string
    try {
      rawContent = await fsp.readFile(absPath, 'utf-8')
    } catch {
      continue
    }

    // Strip the sourceMappingURL comment before processing so it does not affect the content hash.
    let mapUrlMatch = rawContent.match(/\n\/\/# sourceMappingURL=(.+)$/)
    let content = mapUrlMatch ? rawContent.slice(0, mapUrlMatch.index!) : rawContent
    let oldMapUrl = mapUrlMatch ? mapUrlMatch[1] : null
    let contentChanged = false

    // Step 1: Update import specifiers that point to files renamed in earlier iterations.
    if (renames.size > 0) {
      let ms = new MagicString(content)
      for (let [oldLocalPath, newLocalPath] of renames) {
        let oldSpecifier = toLocalRelativeSpecifier(localPath, oldLocalPath)
        if (!content.includes(oldSpecifier)) continue
        let newSpecifier = toLocalRelativeSpecifier(localPath, newLocalPath)
        let idx = 0
        while ((idx = content.indexOf(oldSpecifier, idx)) !== -1) {
          ms.overwrite(idx, idx + oldSpecifier.length, newSpecifier)
          idx += oldSpecifier.length
          contentChanged = true
        }
      }
      if (contentChanged) content = ms.toString()
    }

    // Step 2: Substitute /__@assets/ placeholder strings with real URLs.
    if (content.includes('/__@assets/')) {
      let ms = new MagicString(content)
      let substituted = false

      // Preloads: ['/__@assets/path#preloads'] → full transitive preload list (1:N)
      for (let match of content.matchAll(/\[["'](\/__@assets\/[^"'#]+)#preloads["']\]/g)) {
        let sourcePath = match[1].slice('/__@assets/'.length)
        let preloadUrls = collectPreloadsFromManifest(sourcePath, manifest, baseUrl)
        if (preloadUrls.length > 0) {
          let replacement = '[' + preloadUrls.map((u) => `'${u}'`).join(', ') + ']'
          ms.overwrite(match.index!, match.index! + match[0].length, replacement)
          substituted = true
        }
      }

      // Hrefs: '/__@assets/path' → real hashed URL (1:1)
      for (let match of content.matchAll(/["'](\/__@assets\/[^"'#]+)["']/g)) {
        let sourcePath = match[1].slice('/__@assets/'.length)
        let realUrl = sourcePathToRealUrl.get(sourcePath)
        if (realUrl !== undefined) {
          ms.overwrite(match.index! + 1, match.index! + match[0].length - 1, realUrl)
          substituted = true
        }
      }

      if (substituted) {
        content = ms.toString()
        contentChanged = true
      }
    }

    if (!contentChanged) continue

    // Step 3: Recompute hash → new filename → update disk and manifest.
    let newHash = await computeSubstituteHash(content)
    let newAbsPath = renameFile(absPath, newHash)
    let newLocalPath = toPosixLocalPath(path.relative(outDir, newAbsPath))

    // Reconstruct the sourceMappingURL pointing to the (possibly renamed) .map file.
    let newMapUrl = oldMapUrl
      ? oldMapUrl.replace(path.basename(absPath), path.basename(newAbsPath))
      : null
    let finalContent = newMapUrl != null ? `${content}\n//# sourceMappingURL=${newMapUrl}` : content

    await fsp.mkdir(path.dirname(newAbsPath), { recursive: true })
    await fsp.writeFile(newAbsPath, finalContent, 'utf-8')

    if (newAbsPath !== absPath) {
      await fsp.unlink(absPath)

      // Rename the accompanying .map file if it exists.
      try {
        await fsp.rename(absPath + '.map', newAbsPath + '.map')
      } catch {
        // No .map file, that's fine.
      }

      renames.set(localPath, newLocalPath)

      // Update the manifest key for the JS file.
      let entry = manifest.scripts.outputs[localPath]
      if (entry) {
        manifest.scripts.outputs[newLocalPath] = entry
        delete manifest.scripts.outputs[localPath]
      }

      // Update the manifest key for the .map file.
      let oldMapLocalPath = `${localPath}.map`
      let newMapLocalPath = `${newLocalPath}.map`
      let mapEntry = manifest.scripts.outputs[oldMapLocalPath]
      if (mapEntry) {
        manifest.scripts.outputs[newMapLocalPath] = mapEntry
        delete manifest.scripts.outputs[oldMapLocalPath]
      }

      // Update all import references in the manifest that pointed to the old path.
      for (let mEntry of Object.values(manifest.scripts.outputs)) {
        if (mEntry.imports) {
          for (let imp of mEntry.imports) {
            if (imp.path === localPath) imp.path = newLocalPath
          }
        }
      }
    }
  }
}
