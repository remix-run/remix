import type { GlobMatchOptions } from './types.ts'

export type GlobParityCase = {
  name: string
  path: string
  pattern: string
  options?: GlobMatchOptions
  expected: boolean
}

export const globParityCases = [
  // literals + wildcards
  { name: 'literal exact', path: 'abc', pattern: 'abc', expected: true },
  { name: 'literal mismatch', path: 'abc', pattern: 'abd', expected: false },
  { name: 'star matches segment', path: 'abc', pattern: '*', expected: true },
  { name: 'star does not cross slash', path: 'abc/def', pattern: '*', expected: false },
  { name: 'star suffix', path: 'abc', pattern: 'a*', expected: true },
  { name: 'star suffix does not cross slash', path: 'ab/c', pattern: 'a*', expected: false },
  { name: 'question mark matches single char', path: 'ab', pattern: 'a?', expected: true },
  { name: 'question mark requires one char', path: 'a', pattern: 'a?', expected: false },
  { name: 'question mark does not cross slash', path: 'ab/c', pattern: 'a?', expected: false },
  { name: 'globstar recursive', path: 'a/b/d/c', pattern: 'a/**/c', expected: true },
  { name: 'globstar zero segments', path: 'a/c', pattern: 'a/**/c', expected: true },
  { name: 'globstar mismatch', path: 'a/b/d', pattern: 'a/**/c', expected: false },
  { name: 'collapsed stars', path: 'abc', pattern: 'a***c', expected: true },
  { name: 'collapsed stars with question', path: 'abc', pattern: 'a*****?c', expected: true },
  { name: 'double globstar path match', path: 'a/b', pattern: '**', expected: true },
  { name: 'double globstar dot segment default', path: 'a/.d', pattern: '**', expected: false },
  {
    name: 'double globstar dot segment with dot option',
    path: 'a/.d',
    pattern: '**',
    options: { dot: true },
    expected: true,
  },

  // escaping
  { name: 'escaped star literal', path: '*', pattern: '\\*', expected: true },
  { name: 'escaped question literal', path: '?', pattern: '\\?', expected: true },
  { name: 'escaped left bracket literal', path: '[', pattern: '[[]', expected: true },
  { name: 'escaped backslash in class', path: '\\', pattern: '[\\\\]', expected: true },
  { name: 'escaped star in text', path: 'a*b', pattern: 'a\\*b', expected: true },
  { name: 'escaped question in text', path: 'a?b', pattern: 'a\\?b', expected: true },

  // braces
  { name: 'brace set match', path: 'app/logo.png', pattern: '**/*.{png,jpg,jpeg}', expected: true },
  { name: 'brace set miss', path: 'app/logo.gif', pattern: '**/*.{png,jpg,jpeg}', expected: false },
  {
    name: 'brace alternatives include globstar',
    path: 'x/c',
    pattern: '{a,b,**}/c',
    expected: true,
  },
  { name: 'brace alternatives miss', path: 'x/c', pattern: '{a,b}/c', expected: false },
  {
    name: 'brace alternatives direct match',
    path: 'b/file.ts',
    pattern: '{a,b}/file.ts',
    expected: true,
  },
  { name: 'numeric range ascending', path: '2/file.ts', pattern: '{1..3}/file.ts', expected: true },
  {
    name: 'numeric range descending',
    path: '2/file.ts',
    pattern: '{3..1}/file.ts',
    expected: true,
  },
  {
    name: 'numeric range ascending low bound',
    path: '1/file.ts',
    pattern: '{1..3}/file.ts',
    expected: true,
  },
  {
    name: 'numeric range ascending high bound',
    path: '3/file.ts',
    pattern: '{1..3}/file.ts',
    expected: true,
  },
  {
    name: 'numeric range below bound miss',
    path: '0/file.ts',
    pattern: '{1..3}/file.ts',
    expected: false,
  },
  { name: 'numeric range miss', path: '9/file.ts', pattern: '{1..3}/file.ts', expected: false },
  {
    name: 'numeric range descending low bound',
    path: '1/file.ts',
    pattern: '{3..1}/file.ts',
    expected: true,
  },
  {
    name: 'numeric range descending high bound',
    path: '3/file.ts',
    pattern: '{3..1}/file.ts',
    expected: true,
  },
  {
    name: 'numeric range descending miss',
    path: '4/file.ts',
    pattern: '{3..1}/file.ts',
    expected: false,
  },
  {
    name: 'numeric range singleton match',
    path: '5/file.ts',
    pattern: '{5..5}/file.ts',
    expected: true,
  },
  {
    name: 'numeric range singleton miss',
    path: '4/file.ts',
    pattern: '{5..5}/file.ts',
    expected: false,
  },
  { name: 'alpha range ascending', path: 'b/file.ts', pattern: '{a..c}/file.ts', expected: true },
  { name: 'alpha range descending', path: 'b/file.ts', pattern: '{c..a}/file.ts', expected: true },
  {
    name: 'alpha range ascending low bound',
    path: 'a/file.ts',
    pattern: '{a..c}/file.ts',
    expected: true,
  },
  {
    name: 'alpha range ascending high bound',
    path: 'c/file.ts',
    pattern: '{a..c}/file.ts',
    expected: true,
  },
  {
    name: 'alpha range ascending miss',
    path: 'd/file.ts',
    pattern: '{a..c}/file.ts',
    expected: false,
  },
  {
    name: 'alpha range descending low bound',
    path: 'a/file.ts',
    pattern: '{c..a}/file.ts',
    expected: true,
  },
  {
    name: 'alpha range descending high bound',
    path: 'c/file.ts',
    pattern: '{c..a}/file.ts',
    expected: true,
  },
  {
    name: 'alpha range singleton match',
    path: 'z/file.ts',
    pattern: '{z..z}/file.ts',
    expected: true,
  },
  {
    name: 'alpha range singleton miss',
    path: 'y/file.ts',
    pattern: '{z..z}/file.ts',
    expected: false,
  },
  { name: 'alpha range miss', path: 'z/file.ts', pattern: '{a..c}/file.ts', expected: false },
  { name: 'inline numeric range match', path: 'v2.ts', pattern: 'v{1..3}.ts', expected: true },
  { name: 'inline numeric range miss', path: 'v4.ts', pattern: 'v{1..3}.ts', expected: false },
  {
    name: 'mixed brace range and literal match',
    path: 'v8.ts',
    pattern: 'v{1..3,8}.ts',
    expected: true,
  },
  {
    name: 'mixed brace range and literal miss',
    path: 'v9.ts',
    pattern: 'v{1..3,8}.ts',
    expected: false,
  },
  { name: 'brace set path segment match', path: 'x/a/c', pattern: 'x/{a,b}/c', expected: true },
  { name: 'brace set path segment miss', path: 'x/d/c', pattern: 'x/{a,b}/c', expected: false },
  {
    name: 'nobrace range-like pattern is literal',
    path: 'v2.ts',
    pattern: 'v{1..3}.ts',
    options: { nobrace: true },
    expected: false,
  },
  {
    name: 'nobrace range-like literal text match',
    path: 'v{1..3}.ts',
    pattern: 'v{1..3}.ts',
    options: { nobrace: true },
    expected: true,
  },
  {
    name: 'nobrace keeps braces literal',
    path: 'x.ts',
    pattern: 'x.{ts,js}',
    options: { nobrace: true },
    expected: false,
  },
  {
    name: 'nobrace literal with braces',
    path: 'x.{ts,js}',
    pattern: 'x.{ts,js}',
    options: { nobrace: true },
    expected: true,
  },
  { name: 'extglob with brace alternative one', path: 'ab', pattern: '*(a|{b,c})', expected: true },
  { name: 'extglob with brace alternative two', path: 'ac', pattern: '*(a|{b,c})', expected: true },

  // character classes + posix classes
  {
    name: 'digit class match',
    path: 'app/logo5.png',
    pattern: 'app/logo[0-9].png',
    expected: true,
  },
  {
    name: 'digit class miss',
    path: 'app/logoa.png',
    pattern: 'app/logo[0-9].png',
    expected: false,
  },
  {
    name: 'negated class match',
    path: 'app/logoa.png',
    pattern: 'app/logo[!0-9].png',
    expected: true,
  },
  {
    name: 'negated class miss',
    path: 'app/logo5.png',
    pattern: 'app/logo[!0-9].png',
    expected: false,
  },
  { name: 'right bracket literal class', path: ']', pattern: '[]]', expected: true },
  { name: 'alpha range class match', path: 'p', pattern: '[a-z]', expected: true },
  { name: 'alpha range class miss', path: 'A', pattern: '[a-z]', expected: false },
  { name: 'subrange class match', path: 'm', pattern: '[m-z]', expected: true },
  { name: 'subrange class miss', path: 'l', pattern: '[m-z]', expected: false },
  { name: 'negated alpha class match', path: 'a', pattern: '[!b-z]', expected: true },
  { name: 'negated alpha class miss', path: 'm', pattern: '[!b-z]', expected: false },
  { name: 'simple digit class', path: '5', pattern: '[0-9]', expected: true },
  { name: 'simple digit class miss', path: 'x', pattern: '[0-9]', expected: false },
  { name: 'posix digit match', path: '5', pattern: '[[:digit:]]', expected: true },
  { name: 'posix digit miss', path: 'x', pattern: '[[:digit:]]', expected: false },
  { name: 'posix alpha match', path: 'a', pattern: '[[:alpha:]]', expected: true },
  { name: 'posix alpha miss', path: '5', pattern: '[[:alpha:]]', expected: false },
  { name: 'posix xdigit match', path: 'f', pattern: '[[:xdigit:]]', expected: true },
  { name: 'posix xdigit miss', path: 'G', pattern: '[[:xdigit:]]', expected: false },
  { name: 'posix upper match', path: 'A', pattern: '[[:upper:]]', expected: true },
  { name: 'posix upper miss', path: 'a', pattern: '[[:upper:]]', expected: false },
  { name: 'posix lower match', path: 'a', pattern: '[[:lower:]]', expected: true },
  { name: 'posix lower miss', path: 'A', pattern: '[[:lower:]]', expected: false },
  { name: 'posix space match', path: ' ', pattern: '[[:space:]]', expected: true },
  { name: 'posix space miss', path: 'x', pattern: '[[:space:]]', expected: false },
  { name: 'posix word match', path: '_', pattern: '[[:word:]]', expected: true },
  { name: 'posix word miss', path: '-', pattern: '[[:word:]]', expected: false },

  // extglobs
  { name: 'extglob any-of match', path: 'app/main.ts', pattern: 'app/*.@(ts|tsx)', expected: true },
  { name: 'extglob any-of miss', path: 'app/main.js', pattern: 'app/*.@(ts|tsx)', expected: false },
  {
    name: 'extglob any-of second arm',
    path: 'app/main.tsx',
    pattern: 'app/*.@(ts|tsx)',
    expected: true,
  },
  {
    name: 'extglob any-of miss close suffix',
    path: 'app/main.tsxx',
    pattern: 'app/*.@(ts|tsx)',
    expected: false,
  },
  { name: 'extglob negate miss', path: 'foo.js', pattern: '*.!(js)', expected: false },
  { name: 'extglob negate match', path: 'foo.ts', pattern: '*.!(js)', expected: true },
  {
    name: 'extglob negate match non-js extension',
    path: 'foo.bar',
    pattern: '*.!(js)',
    expected: true,
  },
  { name: 'extglob at with suffix match', path: 'fool', pattern: '@(foo)*', expected: true },
  { name: 'extglob at exact match', path: 'foo', pattern: '@(foo)*', expected: true },
  { name: 'extglob at mismatch', path: 'bar', pattern: '@(foo)*', expected: false },
  {
    name: 'extglob optional miss',
    path: 'app/main.css',
    pattern: 'app/*.?(map|ts)',
    expected: false,
  },
  {
    name: 'extglob optional map',
    path: 'app/main.map',
    pattern: 'app/*.?(map|ts)',
    expected: true,
  },
  { name: 'extglob optional ts', path: 'app/main.ts', pattern: 'app/*.?(map|ts)', expected: true },
  { name: 'extglob one-or-more', path: 'app/logoooo', pattern: 'app/log+(o)', expected: true },
  { name: 'extglob one-or-more miss', path: 'app/log', pattern: 'app/log+(o)', expected: false },
  {
    name: 'extglob zero-or-more match zero',
    path: 'app/log',
    pattern: 'app/log*(o)',
    expected: true,
  },
  {
    name: 'extglob zero-or-more match many',
    path: 'app/logoooo',
    pattern: 'app/log*(o)',
    expected: true,
  },
  { name: 'composed extglob match one', path: 'ac', pattern: '+(a)!(b)+(c)', expected: true },
  { name: 'composed extglob match two', path: 'acc', pattern: '+(a)!(b)+(c)', expected: true },
  { name: 'composed extglob match three', path: 'adc', pattern: '+(a)!(b)+(c)', expected: true },
  { name: 'composed extglob miss', path: 'abc', pattern: '+(a)!(b)+(c)', expected: false },
  {
    name: 'extglob with class opening paren literal',
    path: 'a(b',
    pattern: '@(a|a[(])b',
    expected: true,
  },
  {
    name: 'extglob with class closing paren literal',
    path: 'a)b',
    pattern: '@(a|a[)])b',
    expected: true,
  },
  {
    name: 'extglob disabled by noext',
    path: 'x.ts',
    pattern: '@(x.ts)',
    options: { noext: true },
    expected: false,
  },
  {
    name: 'noext literal extglob text',
    path: '@(x.ts)',
    pattern: '@(x.ts)',
    options: { noext: true },
    expected: true,
  },
  {
    name: 'noext complex extglob literal mismatch',
    path: 'a.ts',
    pattern: '*.@(ts|js)',
    options: { noext: true },
    expected: false,
  },
  {
    name: 'noext complex extglob literal match',
    path: 'a.@(ts|js)',
    pattern: '*.@(ts|js)',
    options: { noext: true },
    expected: true,
  },

  // options
  { name: 'dot segment excluded by default', path: 'a/.d/b', pattern: 'a/*/b', expected: false },
  {
    name: 'dot segment included with option',
    path: 'a/.d/b',
    pattern: 'a/*/b',
    options: { dot: true },
    expected: true,
  },
  {
    name: 'dot option still excludes dot segment self',
    path: 'a/./b',
    pattern: 'a/*/b',
    options: { dot: true },
    expected: false,
  },
  {
    name: 'dot option still excludes parent segment',
    path: 'a/../b',
    pattern: 'a/*/b',
    options: { dot: true },
    expected: false,
  },
  {
    name: 'explicit dot pattern works without dot option',
    path: 'a/.d/b',
    pattern: 'a/.*/b',
    expected: true,
  },
  {
    name: 'nocase match',
    path: 'x/Y.ts',
    pattern: 'x/y.ts',
    options: { nocase: true },
    expected: true,
  },
  { name: 'nocase miss without option', path: 'x/Y.ts', pattern: 'x/y.ts', expected: false },
  {
    name: 'nocase full uppercase path',
    path: 'X/Y.TS',
    pattern: 'x/y.ts',
    options: { nocase: true },
    expected: true,
  },
  {
    name: 'nocase full uppercase path miss without option',
    path: 'X/Y.TS',
    pattern: 'x/y.ts',
    expected: false,
  },
  {
    name: 'noglobstar behaves like star',
    path: 'a/b/d/c',
    pattern: 'a/**/c',
    options: { noglobstar: true },
    expected: false,
  },
  {
    name: 'noglobstar still matches one segment',
    path: 'a/b/c',
    pattern: 'a/**/c',
    options: { noglobstar: true },
    expected: true,
  },
  {
    name: 'noglobstar does not recurse in suffix pattern',
    path: 'a/b/c',
    pattern: 'a/**',
    options: { noglobstar: true },
    expected: false,
  },
  {
    name: 'noglobstar literal double-star text',
    path: 'a/**',
    pattern: 'a/**',
    options: { noglobstar: true },
    expected: true,
  },
  {
    name: 'matchBase matches basename',
    path: 'x/y/acb',
    pattern: 'a?b',
    options: { matchBase: true },
    expected: true,
  },
  { name: 'without matchBase misses basename', path: 'x/y/acb', pattern: 'a?b', expected: false },
  {
    name: 'matchBase fails when basename differs',
    path: 'x/y/acb/d',
    pattern: 'a?b',
    options: { matchBase: true },
    expected: false,
  },
  {
    name: 'matchBase handles trailing slash basename',
    path: 'acb/',
    pattern: 'a?b',
    options: { matchBase: true },
    expected: true,
  },
  {
    name: 'matchBase explicit dotfile name',
    path: 'x/y/.env',
    pattern: '.env',
    options: { matchBase: true },
    expected: true,
  },
  {
    name: 'matchBase star excludes dotfile by default',
    path: 'x/y/.env',
    pattern: '*',
    options: { matchBase: true },
    expected: false,
  },
  {
    name: 'matchBase star includes dotfile with dot option',
    path: 'x/y/.env',
    pattern: '*',
    options: { matchBase: true, dot: true },
    expected: true,
  },
  {
    name: 'nocase with wildcard suffix',
    path: 'src/APP.TS',
    pattern: 'src/*.ts',
    options: { nocase: true },
    expected: true,
  },
  {
    name: 'nocase wildcard suffix miss without option',
    path: 'src/APP.TS',
    pattern: 'src/*.ts',
    expected: false,
  },
] as const satisfies readonly GlobParityCase[]
